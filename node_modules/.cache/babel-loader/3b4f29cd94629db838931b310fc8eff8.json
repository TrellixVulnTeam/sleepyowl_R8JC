{"ast":null,"code":"var _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n/**\r\n * This work is licensed under the W3C Software and Document License\r\n * (http://www.w3.org/Consortium/Legal/2015/copyright-software-and-document).\r\n */\n\n\n(function () {\n  // Return early if we're not running inside of the browser.\n  if (typeof window === 'undefined') {\n    return;\n  } // Convenience function for converting NodeLists.\n\n  /** @type {typeof Array.prototype.slice} */\n\n\n  var slice = Array.prototype.slice;\n  /**\r\n   * IE has a non-standard name for \"matches\".\r\n   * @type {typeof Element.prototype.matches}\r\n   */\n\n  var matches = Element.prototype.matches || Element.prototype.msMatchesSelector;\n  /** @type {string} */\n\n  var _focusableElementsString = ['a[href]', 'area[href]', 'input:not([disabled])', 'select:not([disabled])', 'textarea:not([disabled])', 'button:not([disabled])', 'details', 'summary', 'iframe', 'object', 'embed', '[contenteditable]'].join(',');\n  /**\r\n   * `InertRoot` manages a single inert subtree, i.e. a DOM subtree whose root element has an `inert`\r\n   * attribute.\r\n   *\r\n   * Its main functions are:\r\n   *\r\n   * - to create and maintain a set of managed `InertNode`s, including when mutations occur in the\r\n   *   subtree. The `makeSubtreeUnfocusable()` method handles collecting `InertNode`s via registering\r\n   *   each focusable node in the subtree with the singleton `InertManager` which manages all known\r\n   *   focusable nodes within inert subtrees. `InertManager` ensures that a single `InertNode`\r\n   *   instance exists for each focusable node which has at least one inert root as an ancestor.\r\n   *\r\n   * - to notify all managed `InertNode`s when this subtree stops being inert (i.e. when the `inert`\r\n   *   attribute is removed from the root node). This is handled in the destructor, which calls the\r\n   *   `deregister` method on `InertManager` for each managed inert node.\r\n   */\n\n\n  var InertRoot = function () {\n    /**\r\n     * @param {!Element} rootElement The Element at the root of the inert subtree.\r\n     * @param {!InertManager} inertManager The global singleton InertManager object.\r\n     */\n    function InertRoot(rootElement, inertManager) {\n      _classCallCheck(this, InertRoot);\n      /** @type {!InertManager} */\n\n\n      this._inertManager = inertManager;\n      /** @type {!Element} */\n\n      this._rootElement = rootElement;\n      /**\r\n       * @type {!Set<!InertNode>}\r\n       * All managed focusable nodes in this InertRoot's subtree.\r\n       */\n\n      this._managedNodes = new Set(); // Make the subtree hidden from assistive technology\n\n      if (this._rootElement.hasAttribute('aria-hidden')) {\n        /** @type {?string} */\n        this._savedAriaHidden = this._rootElement.getAttribute('aria-hidden');\n      } else {\n        this._savedAriaHidden = null;\n      }\n\n      this._rootElement.setAttribute('aria-hidden', 'true'); // Make all focusable elements in the subtree unfocusable and add them to _managedNodes\n\n\n      this._makeSubtreeUnfocusable(this._rootElement); // Watch for:\n      // - any additions in the subtree: make them unfocusable too\n      // - any removals from the subtree: remove them from this inert root's managed nodes\n      // - attribute changes: if `tabindex` is added, or removed from an intrinsically focusable\n      //   element, make that node a managed node.\n\n\n      this._observer = new MutationObserver(this._onMutation.bind(this));\n\n      this._observer.observe(this._rootElement, {\n        attributes: true,\n        childList: true,\n        subtree: true\n      });\n    }\n    /**\r\n     * Call this whenever this object is about to become obsolete.  This unwinds all of the state\r\n     * stored in this object and updates the state of all of the managed nodes.\r\n     */\n\n\n    _createClass(InertRoot, [{\n      key: 'destructor',\n      value: function destructor() {\n        this._observer.disconnect();\n\n        if (this._rootElement) {\n          if (this._savedAriaHidden !== null) {\n            this._rootElement.setAttribute('aria-hidden', this._savedAriaHidden);\n          } else {\n            this._rootElement.removeAttribute('aria-hidden');\n          }\n        }\n\n        this._managedNodes.forEach(function (inertNode) {\n          this._unmanageNode(inertNode.node);\n        }, this); // Note we cast the nulls to the ANY type here because:\n        // 1) We want the class properties to be declared as non-null, or else we\n        //    need even more casts throughout this code. All bets are off if an\n        //    instance has been destroyed and a method is called.\n        // 2) We don't want to cast \"this\", because we want type-aware optimizations\n        //    to know which properties we're setting.\n\n\n        this._observer =\n        /** @type {?} */\n        null;\n        this._rootElement =\n        /** @type {?} */\n        null;\n        this._managedNodes =\n        /** @type {?} */\n        null;\n        this._inertManager =\n        /** @type {?} */\n        null;\n      }\n      /**\r\n       * @return {!Set<!InertNode>} A copy of this InertRoot's managed nodes set.\r\n       */\n\n    }, {\n      key: '_makeSubtreeUnfocusable',\n\n      /**\r\n       * @param {!Node} startNode\r\n       */\n      value: function _makeSubtreeUnfocusable(startNode) {\n        var _this2 = this;\n\n        composedTreeWalk(startNode, function (node) {\n          return _this2._visitNode(node);\n        });\n        var activeElement = document.activeElement;\n\n        if (!document.body.contains(startNode)) {\n          // startNode may be in shadow DOM, so find its nearest shadowRoot to get the activeElement.\n          var node = startNode;\n          /** @type {!ShadowRoot|undefined} */\n\n          var root = undefined;\n\n          while (node) {\n            if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n              root =\n              /** @type {!ShadowRoot} */\n              node;\n              break;\n            }\n\n            node = node.parentNode;\n          }\n\n          if (root) {\n            activeElement = root.activeElement;\n          }\n        }\n\n        if (startNode.contains(activeElement)) {\n          activeElement.blur(); // In IE11, if an element is already focused, and then set to tabindex=-1\n          // calling blur() will not actually move the focus.\n          // To work around this we call focus() on the body instead.\n\n          if (activeElement === document.activeElement) {\n            document.body.focus();\n          }\n        }\n      }\n      /**\r\n       * @param {!Node} node\r\n       */\n\n    }, {\n      key: '_visitNode',\n      value: function _visitNode(node) {\n        if (node.nodeType !== Node.ELEMENT_NODE) {\n          return;\n        }\n\n        var element =\n        /** @type {!Element} */\n        node; // If a descendant inert root becomes un-inert, its descendants will still be inert because of\n        // this inert root, so all of its managed nodes need to be adopted by this InertRoot.\n\n        if (element !== this._rootElement && element.hasAttribute('inert')) {\n          this._adoptInertRoot(element);\n        }\n\n        if (matches.call(element, _focusableElementsString) || element.hasAttribute('tabindex')) {\n          this._manageNode(element);\n        }\n      }\n      /**\r\n       * Register the given node with this InertRoot and with InertManager.\r\n       * @param {!Node} node\r\n       */\n\n    }, {\n      key: '_manageNode',\n      value: function _manageNode(node) {\n        var inertNode = this._inertManager.register(node, this);\n\n        this._managedNodes.add(inertNode);\n      }\n      /**\r\n       * Unregister the given node with this InertRoot and with InertManager.\r\n       * @param {!Node} node\r\n       */\n\n    }, {\n      key: '_unmanageNode',\n      value: function _unmanageNode(node) {\n        var inertNode = this._inertManager.deregister(node, this);\n\n        if (inertNode) {\n          this._managedNodes['delete'](inertNode);\n        }\n      }\n      /**\r\n       * Unregister the entire subtree starting at `startNode`.\r\n       * @param {!Node} startNode\r\n       */\n\n    }, {\n      key: '_unmanageSubtree',\n      value: function _unmanageSubtree(startNode) {\n        var _this3 = this;\n\n        composedTreeWalk(startNode, function (node) {\n          return _this3._unmanageNode(node);\n        });\n      }\n      /**\r\n       * If a descendant node is found with an `inert` attribute, adopt its managed nodes.\r\n       * @param {!Element} node\r\n       */\n\n    }, {\n      key: '_adoptInertRoot',\n      value: function _adoptInertRoot(node) {\n        var inertSubroot = this._inertManager.getInertRoot(node); // During initialisation this inert root may not have been registered yet,\n        // so register it now if need be.\n\n\n        if (!inertSubroot) {\n          this._inertManager.setInert(node, true);\n\n          inertSubroot = this._inertManager.getInertRoot(node);\n        }\n\n        inertSubroot.managedNodes.forEach(function (savedInertNode) {\n          this._manageNode(savedInertNode.node);\n        }, this);\n      }\n      /**\r\n       * Callback used when mutation observer detects subtree additions, removals, or attribute changes.\r\n       * @param {!Array<!MutationRecord>} records\r\n       * @param {!MutationObserver} self\r\n       */\n\n    }, {\n      key: '_onMutation',\n      value: function _onMutation(records, self) {\n        records.forEach(function (record) {\n          var target =\n          /** @type {!Element} */\n          record.target;\n\n          if (record.type === 'childList') {\n            // Manage added nodes\n            slice.call(record.addedNodes).forEach(function (node) {\n              this._makeSubtreeUnfocusable(node);\n            }, this); // Un-manage removed nodes\n\n            slice.call(record.removedNodes).forEach(function (node) {\n              this._unmanageSubtree(node);\n            }, this);\n          } else if (record.type === 'attributes') {\n            if (record.attributeName === 'tabindex') {\n              // Re-initialise inert node if tabindex changes\n              this._manageNode(target);\n            } else if (target !== this._rootElement && record.attributeName === 'inert' && target.hasAttribute('inert')) {\n              // If a new inert root is added, adopt its managed nodes and make sure it knows about the\n              // already managed nodes from this inert subroot.\n              this._adoptInertRoot(target);\n\n              var inertSubroot = this._inertManager.getInertRoot(target);\n\n              this._managedNodes.forEach(function (managedNode) {\n                if (target.contains(managedNode.node)) {\n                  inertSubroot._manageNode(managedNode.node);\n                }\n              });\n            }\n          }\n        }, this);\n      }\n    }, {\n      key: 'managedNodes',\n      get: function get() {\n        return new Set(this._managedNodes);\n      }\n      /** @return {boolean} */\n\n    }, {\n      key: 'hasSavedAriaHidden',\n      get: function get() {\n        return this._savedAriaHidden !== null;\n      }\n      /** @param {?string} ariaHidden */\n\n    }, {\n      key: 'savedAriaHidden',\n      set: function set(ariaHidden) {\n        this._savedAriaHidden = ariaHidden;\n      }\n      /** @return {?string} */\n      ,\n      get: function get() {\n        return this._savedAriaHidden;\n      }\n    }]);\n\n    return InertRoot;\n  }();\n  /**\r\n   * `InertNode` initialises and manages a single inert node.\r\n   * A node is inert if it is a descendant of one or more inert root elements.\r\n   *\r\n   * On construction, `InertNode` saves the existing `tabindex` value for the node, if any, and\r\n   * either removes the `tabindex` attribute or sets it to `-1`, depending on whether the element\r\n   * is intrinsically focusable or not.\r\n   *\r\n   * `InertNode` maintains a set of `InertRoot`s which are descendants of this `InertNode`. When an\r\n   * `InertRoot` is destroyed, and calls `InertManager.deregister()`, the `InertManager` notifies the\r\n   * `InertNode` via `removeInertRoot()`, which in turn destroys the `InertNode` if no `InertRoot`s\r\n   * remain in the set. On destruction, `InertNode` reinstates the stored `tabindex` if one exists,\r\n   * or removes the `tabindex` attribute if the element is intrinsically focusable.\r\n   */\n\n\n  var InertNode = function () {\n    /**\r\n     * @param {!Node} node A focusable element to be made inert.\r\n     * @param {!InertRoot} inertRoot The inert root element associated with this inert node.\r\n     */\n    function InertNode(node, inertRoot) {\n      _classCallCheck(this, InertNode);\n      /** @type {!Node} */\n\n\n      this._node = node;\n      /** @type {boolean} */\n\n      this._overrodeFocusMethod = false;\n      /**\r\n       * @type {!Set<!InertRoot>} The set of descendant inert roots.\r\n       *    If and only if this set becomes empty, this node is no longer inert.\r\n       */\n\n      this._inertRoots = new Set([inertRoot]);\n      /** @type {?number} */\n\n      this._savedTabIndex = null;\n      /** @type {boolean} */\n\n      this._destroyed = false; // Save any prior tabindex info and make this node untabbable\n\n      this.ensureUntabbable();\n    }\n    /**\r\n     * Call this whenever this object is about to become obsolete.\r\n     * This makes the managed node focusable again and deletes all of the previously stored state.\r\n     */\n\n\n    _createClass(InertNode, [{\n      key: 'destructor',\n      value: function destructor() {\n        this._throwIfDestroyed();\n\n        if (this._node && this._node.nodeType === Node.ELEMENT_NODE) {\n          var element =\n          /** @type {!Element} */\n          this._node;\n\n          if (this._savedTabIndex !== null) {\n            element.setAttribute('tabindex', this._savedTabIndex);\n          } else {\n            element.removeAttribute('tabindex');\n          } // Use `delete` to restore native focus method.\n\n\n          if (this._overrodeFocusMethod) {\n            delete element.focus;\n          }\n        } // See note in InertRoot.destructor for why we cast these nulls to ANY.\n\n\n        this._node =\n        /** @type {?} */\n        null;\n        this._inertRoots =\n        /** @type {?} */\n        null;\n        this._destroyed = true;\n      }\n      /**\r\n       * @type {boolean} Whether this object is obsolete because the managed node is no longer inert.\r\n       * If the object has been destroyed, any attempt to access it will cause an exception.\r\n       */\n\n    }, {\n      key: '_throwIfDestroyed',\n\n      /**\r\n       * Throw if user tries to access destroyed InertNode.\r\n       */\n      value: function _throwIfDestroyed() {\n        if (this.destroyed) {\n          throw new Error('Trying to access destroyed InertNode');\n        }\n      }\n      /** @return {boolean} */\n\n    }, {\n      key: 'ensureUntabbable',\n\n      /** Save the existing tabindex value and make the node untabbable and unfocusable */\n      value: function ensureUntabbable() {\n        if (this.node.nodeType !== Node.ELEMENT_NODE) {\n          return;\n        }\n\n        var element =\n        /** @type {!Element} */\n        this.node;\n\n        if (matches.call(element, _focusableElementsString)) {\n          if (\n          /** @type {!HTMLElement} */\n          element.tabIndex === -1 && this.hasSavedTabIndex) {\n            return;\n          }\n\n          if (element.hasAttribute('tabindex')) {\n            this._savedTabIndex =\n            /** @type {!HTMLElement} */\n            element.tabIndex;\n          }\n\n          element.setAttribute('tabindex', '-1');\n\n          if (element.nodeType === Node.ELEMENT_NODE) {\n            element.focus = function () {};\n\n            this._overrodeFocusMethod = true;\n          }\n        } else if (element.hasAttribute('tabindex')) {\n          this._savedTabIndex =\n          /** @type {!HTMLElement} */\n          element.tabIndex;\n          element.removeAttribute('tabindex');\n        }\n      }\n      /**\r\n       * Add another inert root to this inert node's set of managing inert roots.\r\n       * @param {!InertRoot} inertRoot\r\n       */\n\n    }, {\n      key: 'addInertRoot',\n      value: function addInertRoot(inertRoot) {\n        this._throwIfDestroyed();\n\n        this._inertRoots.add(inertRoot);\n      }\n      /**\r\n       * Remove the given inert root from this inert node's set of managing inert roots.\r\n       * If the set of managing inert roots becomes empty, this node is no longer inert,\r\n       * so the object should be destroyed.\r\n       * @param {!InertRoot} inertRoot\r\n       */\n\n    }, {\n      key: 'removeInertRoot',\n      value: function removeInertRoot(inertRoot) {\n        this._throwIfDestroyed();\n\n        this._inertRoots['delete'](inertRoot);\n\n        if (this._inertRoots.size === 0) {\n          this.destructor();\n        }\n      }\n    }, {\n      key: 'destroyed',\n      get: function get() {\n        return (\n          /** @type {!InertNode} */\n          this._destroyed\n        );\n      }\n    }, {\n      key: 'hasSavedTabIndex',\n      get: function get() {\n        return this._savedTabIndex !== null;\n      }\n      /** @return {!Node} */\n\n    }, {\n      key: 'node',\n      get: function get() {\n        this._throwIfDestroyed();\n\n        return this._node;\n      }\n      /** @param {?number} tabIndex */\n\n    }, {\n      key: 'savedTabIndex',\n      set: function set(tabIndex) {\n        this._throwIfDestroyed();\n\n        this._savedTabIndex = tabIndex;\n      }\n      /** @return {?number} */\n      ,\n      get: function get() {\n        this._throwIfDestroyed();\n\n        return this._savedTabIndex;\n      }\n    }]);\n\n    return InertNode;\n  }();\n  /**\r\n   * InertManager is a per-document singleton object which manages all inert roots and nodes.\r\n   *\r\n   * When an element becomes an inert root by having an `inert` attribute set and/or its `inert`\r\n   * property set to `true`, the `setInert` method creates an `InertRoot` object for the element.\r\n   * The `InertRoot` in turn registers itself as managing all of the element's focusable descendant\r\n   * nodes via the `register()` method. The `InertManager` ensures that a single `InertNode` instance\r\n   * is created for each such node, via the `_managedNodes` map.\r\n   */\n\n\n  var InertManager = function () {\n    /**\r\n     * @param {!Document} document\r\n     */\n    function InertManager(document) {\n      _classCallCheck(this, InertManager);\n\n      if (!document) {\n        throw new Error('Missing required argument; InertManager needs to wrap a document.');\n      }\n      /** @type {!Document} */\n\n\n      this._document = document;\n      /**\r\n       * All managed nodes known to this InertManager. In a map to allow looking up by Node.\r\n       * @type {!Map<!Node, !InertNode>}\r\n       */\n\n      this._managedNodes = new Map();\n      /**\r\n       * All inert roots known to this InertManager. In a map to allow looking up by Node.\r\n       * @type {!Map<!Node, !InertRoot>}\r\n       */\n\n      this._inertRoots = new Map();\n      /**\r\n       * Observer for mutations on `document.body`.\r\n       * @type {!MutationObserver}\r\n       */\n\n      this._observer = new MutationObserver(this._watchForInert.bind(this)); // Add inert style.\n\n      addInertStyle(document.head || document.body || document.documentElement); // Wait for document to be loaded.\n\n      if (document.readyState === 'loading') {\n        document.addEventListener('DOMContentLoaded', this._onDocumentLoaded.bind(this));\n      } else {\n        this._onDocumentLoaded();\n      }\n    }\n    /**\r\n     * Set whether the given element should be an inert root or not.\r\n     * @param {!Element} root\r\n     * @param {boolean} inert\r\n     */\n\n\n    _createClass(InertManager, [{\n      key: 'setInert',\n      value: function setInert(root, inert) {\n        if (inert) {\n          if (this._inertRoots.has(root)) {\n            // element is already inert\n            return;\n          }\n\n          var inertRoot = new InertRoot(root, this);\n          root.setAttribute('inert', '');\n\n          this._inertRoots.set(root, inertRoot); // If not contained in the document, it must be in a shadowRoot.\n          // Ensure inert styles are added there.\n\n\n          if (!this._document.body.contains(root)) {\n            var parent = root.parentNode;\n\n            while (parent) {\n              if (parent.nodeType === 11) {\n                addInertStyle(parent);\n              }\n\n              parent = parent.parentNode;\n            }\n          }\n        } else {\n          if (!this._inertRoots.has(root)) {\n            // element is already non-inert\n            return;\n          }\n\n          var _inertRoot = this._inertRoots.get(root);\n\n          _inertRoot.destructor();\n\n          this._inertRoots['delete'](root);\n\n          root.removeAttribute('inert');\n        }\n      }\n      /**\r\n       * Get the InertRoot object corresponding to the given inert root element, if any.\r\n       * @param {!Node} element\r\n       * @return {!InertRoot|undefined}\r\n       */\n\n    }, {\n      key: 'getInertRoot',\n      value: function getInertRoot(element) {\n        return this._inertRoots.get(element);\n      }\n      /**\r\n       * Register the given InertRoot as managing the given node.\r\n       * In the case where the node has a previously existing inert root, this inert root will\r\n       * be added to its set of inert roots.\r\n       * @param {!Node} node\r\n       * @param {!InertRoot} inertRoot\r\n       * @return {!InertNode} inertNode\r\n       */\n\n    }, {\n      key: 'register',\n      value: function register(node, inertRoot) {\n        var inertNode = this._managedNodes.get(node);\n\n        if (inertNode !== undefined) {\n          // node was already in an inert subtree\n          inertNode.addInertRoot(inertRoot);\n        } else {\n          inertNode = new InertNode(node, inertRoot);\n        }\n\n        this._managedNodes.set(node, inertNode);\n\n        return inertNode;\n      }\n      /**\r\n       * De-register the given InertRoot as managing the given inert node.\r\n       * Removes the inert root from the InertNode's set of managing inert roots, and remove the inert\r\n       * node from the InertManager's set of managed nodes if it is destroyed.\r\n       * If the node is not currently managed, this is essentially a no-op.\r\n       * @param {!Node} node\r\n       * @param {!InertRoot} inertRoot\r\n       * @return {?InertNode} The potentially destroyed InertNode associated with this node, if any.\r\n       */\n\n    }, {\n      key: 'deregister',\n      value: function deregister(node, inertRoot) {\n        var inertNode = this._managedNodes.get(node);\n\n        if (!inertNode) {\n          return null;\n        }\n\n        inertNode.removeInertRoot(inertRoot);\n\n        if (inertNode.destroyed) {\n          this._managedNodes['delete'](node);\n        }\n\n        return inertNode;\n      }\n      /**\r\n       * Callback used when document has finished loading.\r\n       */\n\n    }, {\n      key: '_onDocumentLoaded',\n      value: function _onDocumentLoaded() {\n        // Find all inert roots in document and make them actually inert.\n        var inertElements = slice.call(this._document.querySelectorAll('[inert]'));\n        inertElements.forEach(function (inertElement) {\n          this.setInert(inertElement, true);\n        }, this); // Comment this out to use programmatic API only.\n\n        this._observer.observe(this._document.body || this._document.documentElement, {\n          attributes: true,\n          subtree: true,\n          childList: true\n        });\n      }\n      /**\r\n       * Callback used when mutation observer detects attribute changes.\r\n       * @param {!Array<!MutationRecord>} records\r\n       * @param {!MutationObserver} self\r\n       */\n\n    }, {\n      key: '_watchForInert',\n      value: function _watchForInert(records, self) {\n        var _this = this;\n\n        records.forEach(function (record) {\n          switch (record.type) {\n            case 'childList':\n              slice.call(record.addedNodes).forEach(function (node) {\n                if (node.nodeType !== Node.ELEMENT_NODE) {\n                  return;\n                }\n\n                var inertElements = slice.call(node.querySelectorAll('[inert]'));\n\n                if (matches.call(node, '[inert]')) {\n                  inertElements.unshift(node);\n                }\n\n                inertElements.forEach(function (inertElement) {\n                  this.setInert(inertElement, true);\n                }, _this);\n              }, _this);\n              break;\n\n            case 'attributes':\n              if (record.attributeName !== 'inert') {\n                return;\n              }\n\n              var target =\n              /** @type {!Element} */\n              record.target;\n              var inert = target.hasAttribute('inert');\n\n              _this.setInert(target, inert);\n\n              break;\n          }\n        }, this);\n      }\n    }]);\n\n    return InertManager;\n  }();\n  /**\r\n   * Recursively walk the composed tree from |node|.\r\n   * @param {!Node} node\r\n   * @param {(function (!Element))=} callback Callback to be called for each element traversed,\r\n   *     before descending into child nodes.\r\n   * @param {?ShadowRoot=} shadowRootAncestor The nearest ShadowRoot ancestor, if any.\r\n   */\n\n\n  function composedTreeWalk(node, callback, shadowRootAncestor) {\n    if (node.nodeType == Node.ELEMENT_NODE) {\n      var element =\n      /** @type {!Element} */\n      node;\n\n      if (callback) {\n        callback(element);\n      } // Descend into node:\n      // If it has a ShadowRoot, ignore all child elements - these will be picked\n      // up by the <content> or <shadow> elements. Descend straight into the\n      // ShadowRoot.\n\n\n      var shadowRoot =\n      /** @type {!HTMLElement} */\n      element.shadowRoot;\n\n      if (shadowRoot) {\n        composedTreeWalk(shadowRoot, callback, shadowRoot);\n        return;\n      } // If it is a <content> element, descend into distributed elements - these\n      // are elements from outside the shadow root which are rendered inside the\n      // shadow DOM.\n\n\n      if (element.localName == 'content') {\n        var content =\n        /** @type {!HTMLContentElement} */\n        element; // Verifies if ShadowDom v0 is supported.\n\n        var distributedNodes = content.getDistributedNodes ? content.getDistributedNodes() : [];\n\n        for (var i = 0; i < distributedNodes.length; i++) {\n          composedTreeWalk(distributedNodes[i], callback, shadowRootAncestor);\n        }\n\n        return;\n      } // If it is a <slot> element, descend into assigned nodes - these\n      // are elements from outside the shadow root which are rendered inside the\n      // shadow DOM.\n\n\n      if (element.localName == 'slot') {\n        var slot =\n        /** @type {!HTMLSlotElement} */\n        element; // Verify if ShadowDom v1 is supported.\n\n        var _distributedNodes = slot.assignedNodes ? slot.assignedNodes({\n          flatten: true\n        }) : [];\n\n        for (var _i = 0; _i < _distributedNodes.length; _i++) {\n          composedTreeWalk(_distributedNodes[_i], callback, shadowRootAncestor);\n        }\n\n        return;\n      }\n    } // If it is neither the parent of a ShadowRoot, a <content> element, a <slot>\n    // element, nor a <shadow> element recurse normally.\n\n\n    var child = node.firstChild;\n\n    while (child != null) {\n      composedTreeWalk(child, callback, shadowRootAncestor);\n      child = child.nextSibling;\n    }\n  }\n  /**\r\n   * Adds a style element to the node containing the inert specific styles\r\n   * @param {!Node} node\r\n   */\n\n\n  function addInertStyle(node) {\n    if (node.querySelector('style#inert-style, link#inert-style')) {\n      return;\n    }\n\n    var style = document.createElement('style');\n    style.setAttribute('id', 'inert-style');\n    style.textContent = '\\n' + '[inert] {\\n' + '  pointer-events: none;\\n' + '  cursor: default;\\n' + '}\\n' + '\\n' + '[inert], [inert] * {\\n' + '  -webkit-user-select: none;\\n' + '  -moz-user-select: none;\\n' + '  -ms-user-select: none;\\n' + '  user-select: none;\\n' + '}\\n';\n    node.appendChild(style);\n  }\n\n  if (!Element.prototype.hasOwnProperty('inert')) {\n    /** @type {!InertManager} */\n    var inertManager = new InertManager(document);\n    Object.defineProperty(Element.prototype, 'inert', {\n      enumerable: true,\n\n      /** @this {!Element} */\n      get: function get() {\n        return this.hasAttribute('inert');\n      },\n\n      /** @this {!Element} */\n      set: function set(inert) {\n        inertManager.setInert(this, inert);\n      }\n    });\n  }\n})();","map":{"version":3,"sources":["D:/Rnd/sleepyowl/node_modules/wicg-inert/dist/inert.esm.js"],"names":["_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","Constructor","protoProps","staticProps","prototype","_classCallCheck","instance","TypeError","window","slice","Array","matches","Element","msMatchesSelector","_focusableElementsString","join","InertRoot","rootElement","inertManager","_inertManager","_rootElement","_managedNodes","Set","hasAttribute","_savedAriaHidden","getAttribute","setAttribute","_makeSubtreeUnfocusable","_observer","MutationObserver","_onMutation","bind","observe","attributes","childList","subtree","value","destructor","disconnect","removeAttribute","forEach","inertNode","_unmanageNode","node","startNode","_this2","composedTreeWalk","_visitNode","activeElement","document","body","contains","root","undefined","nodeType","Node","DOCUMENT_FRAGMENT_NODE","parentNode","blur","focus","ELEMENT_NODE","element","_adoptInertRoot","call","_manageNode","register","add","deregister","_unmanageSubtree","_this3","inertSubroot","getInertRoot","setInert","managedNodes","savedInertNode","records","self","record","type","addedNodes","removedNodes","attributeName","managedNode","get","set","ariaHidden","InertNode","inertRoot","_node","_overrodeFocusMethod","_inertRoots","_savedTabIndex","_destroyed","ensureUntabbable","_throwIfDestroyed","destroyed","Error","tabIndex","hasSavedTabIndex","addInertRoot","removeInertRoot","size","InertManager","_document","Map","_watchForInert","addInertStyle","head","documentElement","readyState","addEventListener","_onDocumentLoaded","inert","has","parent","_inertRoot","inertElements","querySelectorAll","inertElement","_this","unshift","callback","shadowRootAncestor","shadowRoot","localName","content","distributedNodes","getDistributedNodes","slot","_distributedNodes","assignedNodes","flatten","_i","child","firstChild","nextSibling","querySelector","style","createElement","textContent","appendChild","hasOwnProperty"],"mappings":"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","sourcesContent":["var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\r\n\r\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\r\n\r\n/**\r\n * This work is licensed under the W3C Software and Document License\r\n * (http://www.w3.org/Consortium/Legal/2015/copyright-software-and-document).\r\n */\r\n\r\n(function () {\r\n  // Return early if we're not running inside of the browser.\r\n  if (typeof window === 'undefined') {\r\n    return;\r\n  }\r\n\r\n  // Convenience function for converting NodeLists.\r\n  /** @type {typeof Array.prototype.slice} */\r\n  var slice = Array.prototype.slice;\r\n\r\n  /**\r\n   * IE has a non-standard name for \"matches\".\r\n   * @type {typeof Element.prototype.matches}\r\n   */\r\n  var matches = Element.prototype.matches || Element.prototype.msMatchesSelector;\r\n\r\n  /** @type {string} */\r\n  var _focusableElementsString = ['a[href]', 'area[href]', 'input:not([disabled])', 'select:not([disabled])', 'textarea:not([disabled])', 'button:not([disabled])', 'details', 'summary', 'iframe', 'object', 'embed', '[contenteditable]'].join(',');\r\n\r\n  /**\r\n   * `InertRoot` manages a single inert subtree, i.e. a DOM subtree whose root element has an `inert`\r\n   * attribute.\r\n   *\r\n   * Its main functions are:\r\n   *\r\n   * - to create and maintain a set of managed `InertNode`s, including when mutations occur in the\r\n   *   subtree. The `makeSubtreeUnfocusable()` method handles collecting `InertNode`s via registering\r\n   *   each focusable node in the subtree with the singleton `InertManager` which manages all known\r\n   *   focusable nodes within inert subtrees. `InertManager` ensures that a single `InertNode`\r\n   *   instance exists for each focusable node which has at least one inert root as an ancestor.\r\n   *\r\n   * - to notify all managed `InertNode`s when this subtree stops being inert (i.e. when the `inert`\r\n   *   attribute is removed from the root node). This is handled in the destructor, which calls the\r\n   *   `deregister` method on `InertManager` for each managed inert node.\r\n   */\r\n\r\n  var InertRoot = function () {\r\n    /**\r\n     * @param {!Element} rootElement The Element at the root of the inert subtree.\r\n     * @param {!InertManager} inertManager The global singleton InertManager object.\r\n     */\r\n    function InertRoot(rootElement, inertManager) {\r\n      _classCallCheck(this, InertRoot);\r\n\r\n      /** @type {!InertManager} */\r\n      this._inertManager = inertManager;\r\n\r\n      /** @type {!Element} */\r\n      this._rootElement = rootElement;\r\n\r\n      /**\r\n       * @type {!Set<!InertNode>}\r\n       * All managed focusable nodes in this InertRoot's subtree.\r\n       */\r\n      this._managedNodes = new Set();\r\n\r\n      // Make the subtree hidden from assistive technology\r\n      if (this._rootElement.hasAttribute('aria-hidden')) {\r\n        /** @type {?string} */\r\n        this._savedAriaHidden = this._rootElement.getAttribute('aria-hidden');\r\n      } else {\r\n        this._savedAriaHidden = null;\r\n      }\r\n      this._rootElement.setAttribute('aria-hidden', 'true');\r\n\r\n      // Make all focusable elements in the subtree unfocusable and add them to _managedNodes\r\n      this._makeSubtreeUnfocusable(this._rootElement);\r\n\r\n      // Watch for:\r\n      // - any additions in the subtree: make them unfocusable too\r\n      // - any removals from the subtree: remove them from this inert root's managed nodes\r\n      // - attribute changes: if `tabindex` is added, or removed from an intrinsically focusable\r\n      //   element, make that node a managed node.\r\n      this._observer = new MutationObserver(this._onMutation.bind(this));\r\n      this._observer.observe(this._rootElement, { attributes: true, childList: true, subtree: true });\r\n    }\r\n\r\n    /**\r\n     * Call this whenever this object is about to become obsolete.  This unwinds all of the state\r\n     * stored in this object and updates the state of all of the managed nodes.\r\n     */\r\n\r\n\r\n    _createClass(InertRoot, [{\r\n      key: 'destructor',\r\n      value: function destructor() {\r\n        this._observer.disconnect();\r\n\r\n        if (this._rootElement) {\r\n          if (this._savedAriaHidden !== null) {\r\n            this._rootElement.setAttribute('aria-hidden', this._savedAriaHidden);\r\n          } else {\r\n            this._rootElement.removeAttribute('aria-hidden');\r\n          }\r\n        }\r\n\r\n        this._managedNodes.forEach(function (inertNode) {\r\n          this._unmanageNode(inertNode.node);\r\n        }, this);\r\n\r\n        // Note we cast the nulls to the ANY type here because:\r\n        // 1) We want the class properties to be declared as non-null, or else we\r\n        //    need even more casts throughout this code. All bets are off if an\r\n        //    instance has been destroyed and a method is called.\r\n        // 2) We don't want to cast \"this\", because we want type-aware optimizations\r\n        //    to know which properties we're setting.\r\n        this._observer = /** @type {?} */null;\r\n        this._rootElement = /** @type {?} */null;\r\n        this._managedNodes = /** @type {?} */null;\r\n        this._inertManager = /** @type {?} */null;\r\n      }\r\n\r\n      /**\r\n       * @return {!Set<!InertNode>} A copy of this InertRoot's managed nodes set.\r\n       */\r\n\r\n    }, {\r\n      key: '_makeSubtreeUnfocusable',\r\n\r\n\r\n      /**\r\n       * @param {!Node} startNode\r\n       */\r\n      value: function _makeSubtreeUnfocusable(startNode) {\r\n        var _this2 = this;\r\n\r\n        composedTreeWalk(startNode, function (node) {\r\n          return _this2._visitNode(node);\r\n        });\r\n\r\n        var activeElement = document.activeElement;\r\n\r\n        if (!document.body.contains(startNode)) {\r\n          // startNode may be in shadow DOM, so find its nearest shadowRoot to get the activeElement.\r\n          var node = startNode;\r\n          /** @type {!ShadowRoot|undefined} */\r\n          var root = undefined;\r\n          while (node) {\r\n            if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\r\n              root = /** @type {!ShadowRoot} */node;\r\n              break;\r\n            }\r\n            node = node.parentNode;\r\n          }\r\n          if (root) {\r\n            activeElement = root.activeElement;\r\n          }\r\n        }\r\n        if (startNode.contains(activeElement)) {\r\n          activeElement.blur();\r\n          // In IE11, if an element is already focused, and then set to tabindex=-1\r\n          // calling blur() will not actually move the focus.\r\n          // To work around this we call focus() on the body instead.\r\n          if (activeElement === document.activeElement) {\r\n            document.body.focus();\r\n          }\r\n        }\r\n      }\r\n\r\n      /**\r\n       * @param {!Node} node\r\n       */\r\n\r\n    }, {\r\n      key: '_visitNode',\r\n      value: function _visitNode(node) {\r\n        if (node.nodeType !== Node.ELEMENT_NODE) {\r\n          return;\r\n        }\r\n        var element = /** @type {!Element} */node;\r\n\r\n        // If a descendant inert root becomes un-inert, its descendants will still be inert because of\r\n        // this inert root, so all of its managed nodes need to be adopted by this InertRoot.\r\n        if (element !== this._rootElement && element.hasAttribute('inert')) {\r\n          this._adoptInertRoot(element);\r\n        }\r\n\r\n        if (matches.call(element, _focusableElementsString) || element.hasAttribute('tabindex')) {\r\n          this._manageNode(element);\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Register the given node with this InertRoot and with InertManager.\r\n       * @param {!Node} node\r\n       */\r\n\r\n    }, {\r\n      key: '_manageNode',\r\n      value: function _manageNode(node) {\r\n        var inertNode = this._inertManager.register(node, this);\r\n        this._managedNodes.add(inertNode);\r\n      }\r\n\r\n      /**\r\n       * Unregister the given node with this InertRoot and with InertManager.\r\n       * @param {!Node} node\r\n       */\r\n\r\n    }, {\r\n      key: '_unmanageNode',\r\n      value: function _unmanageNode(node) {\r\n        var inertNode = this._inertManager.deregister(node, this);\r\n        if (inertNode) {\r\n          this._managedNodes['delete'](inertNode);\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Unregister the entire subtree starting at `startNode`.\r\n       * @param {!Node} startNode\r\n       */\r\n\r\n    }, {\r\n      key: '_unmanageSubtree',\r\n      value: function _unmanageSubtree(startNode) {\r\n        var _this3 = this;\r\n\r\n        composedTreeWalk(startNode, function (node) {\r\n          return _this3._unmanageNode(node);\r\n        });\r\n      }\r\n\r\n      /**\r\n       * If a descendant node is found with an `inert` attribute, adopt its managed nodes.\r\n       * @param {!Element} node\r\n       */\r\n\r\n    }, {\r\n      key: '_adoptInertRoot',\r\n      value: function _adoptInertRoot(node) {\r\n        var inertSubroot = this._inertManager.getInertRoot(node);\r\n\r\n        // During initialisation this inert root may not have been registered yet,\r\n        // so register it now if need be.\r\n        if (!inertSubroot) {\r\n          this._inertManager.setInert(node, true);\r\n          inertSubroot = this._inertManager.getInertRoot(node);\r\n        }\r\n\r\n        inertSubroot.managedNodes.forEach(function (savedInertNode) {\r\n          this._manageNode(savedInertNode.node);\r\n        }, this);\r\n      }\r\n\r\n      /**\r\n       * Callback used when mutation observer detects subtree additions, removals, or attribute changes.\r\n       * @param {!Array<!MutationRecord>} records\r\n       * @param {!MutationObserver} self\r\n       */\r\n\r\n    }, {\r\n      key: '_onMutation',\r\n      value: function _onMutation(records, self) {\r\n        records.forEach(function (record) {\r\n          var target = /** @type {!Element} */record.target;\r\n          if (record.type === 'childList') {\r\n            // Manage added nodes\r\n            slice.call(record.addedNodes).forEach(function (node) {\r\n              this._makeSubtreeUnfocusable(node);\r\n            }, this);\r\n\r\n            // Un-manage removed nodes\r\n            slice.call(record.removedNodes).forEach(function (node) {\r\n              this._unmanageSubtree(node);\r\n            }, this);\r\n          } else if (record.type === 'attributes') {\r\n            if (record.attributeName === 'tabindex') {\r\n              // Re-initialise inert node if tabindex changes\r\n              this._manageNode(target);\r\n            } else if (target !== this._rootElement && record.attributeName === 'inert' && target.hasAttribute('inert')) {\r\n              // If a new inert root is added, adopt its managed nodes and make sure it knows about the\r\n              // already managed nodes from this inert subroot.\r\n              this._adoptInertRoot(target);\r\n              var inertSubroot = this._inertManager.getInertRoot(target);\r\n              this._managedNodes.forEach(function (managedNode) {\r\n                if (target.contains(managedNode.node)) {\r\n                  inertSubroot._manageNode(managedNode.node);\r\n                }\r\n              });\r\n            }\r\n          }\r\n        }, this);\r\n      }\r\n    }, {\r\n      key: 'managedNodes',\r\n      get: function get() {\r\n        return new Set(this._managedNodes);\r\n      }\r\n\r\n      /** @return {boolean} */\r\n\r\n    }, {\r\n      key: 'hasSavedAriaHidden',\r\n      get: function get() {\r\n        return this._savedAriaHidden !== null;\r\n      }\r\n\r\n      /** @param {?string} ariaHidden */\r\n\r\n    }, {\r\n      key: 'savedAriaHidden',\r\n      set: function set(ariaHidden) {\r\n        this._savedAriaHidden = ariaHidden;\r\n      }\r\n\r\n      /** @return {?string} */\r\n      ,\r\n      get: function get() {\r\n        return this._savedAriaHidden;\r\n      }\r\n    }]);\r\n\r\n    return InertRoot;\r\n  }();\r\n\r\n  /**\r\n   * `InertNode` initialises and manages a single inert node.\r\n   * A node is inert if it is a descendant of one or more inert root elements.\r\n   *\r\n   * On construction, `InertNode` saves the existing `tabindex` value for the node, if any, and\r\n   * either removes the `tabindex` attribute or sets it to `-1`, depending on whether the element\r\n   * is intrinsically focusable or not.\r\n   *\r\n   * `InertNode` maintains a set of `InertRoot`s which are descendants of this `InertNode`. When an\r\n   * `InertRoot` is destroyed, and calls `InertManager.deregister()`, the `InertManager` notifies the\r\n   * `InertNode` via `removeInertRoot()`, which in turn destroys the `InertNode` if no `InertRoot`s\r\n   * remain in the set. On destruction, `InertNode` reinstates the stored `tabindex` if one exists,\r\n   * or removes the `tabindex` attribute if the element is intrinsically focusable.\r\n   */\r\n\r\n\r\n  var InertNode = function () {\r\n    /**\r\n     * @param {!Node} node A focusable element to be made inert.\r\n     * @param {!InertRoot} inertRoot The inert root element associated with this inert node.\r\n     */\r\n    function InertNode(node, inertRoot) {\r\n      _classCallCheck(this, InertNode);\r\n\r\n      /** @type {!Node} */\r\n      this._node = node;\r\n\r\n      /** @type {boolean} */\r\n      this._overrodeFocusMethod = false;\r\n\r\n      /**\r\n       * @type {!Set<!InertRoot>} The set of descendant inert roots.\r\n       *    If and only if this set becomes empty, this node is no longer inert.\r\n       */\r\n      this._inertRoots = new Set([inertRoot]);\r\n\r\n      /** @type {?number} */\r\n      this._savedTabIndex = null;\r\n\r\n      /** @type {boolean} */\r\n      this._destroyed = false;\r\n\r\n      // Save any prior tabindex info and make this node untabbable\r\n      this.ensureUntabbable();\r\n    }\r\n\r\n    /**\r\n     * Call this whenever this object is about to become obsolete.\r\n     * This makes the managed node focusable again and deletes all of the previously stored state.\r\n     */\r\n\r\n\r\n    _createClass(InertNode, [{\r\n      key: 'destructor',\r\n      value: function destructor() {\r\n        this._throwIfDestroyed();\r\n\r\n        if (this._node && this._node.nodeType === Node.ELEMENT_NODE) {\r\n          var element = /** @type {!Element} */this._node;\r\n          if (this._savedTabIndex !== null) {\r\n            element.setAttribute('tabindex', this._savedTabIndex);\r\n          } else {\r\n            element.removeAttribute('tabindex');\r\n          }\r\n\r\n          // Use `delete` to restore native focus method.\r\n          if (this._overrodeFocusMethod) {\r\n            delete element.focus;\r\n          }\r\n        }\r\n\r\n        // See note in InertRoot.destructor for why we cast these nulls to ANY.\r\n        this._node = /** @type {?} */null;\r\n        this._inertRoots = /** @type {?} */null;\r\n        this._destroyed = true;\r\n      }\r\n\r\n      /**\r\n       * @type {boolean} Whether this object is obsolete because the managed node is no longer inert.\r\n       * If the object has been destroyed, any attempt to access it will cause an exception.\r\n       */\r\n\r\n    }, {\r\n      key: '_throwIfDestroyed',\r\n\r\n\r\n      /**\r\n       * Throw if user tries to access destroyed InertNode.\r\n       */\r\n      value: function _throwIfDestroyed() {\r\n        if (this.destroyed) {\r\n          throw new Error('Trying to access destroyed InertNode');\r\n        }\r\n      }\r\n\r\n      /** @return {boolean} */\r\n\r\n    }, {\r\n      key: 'ensureUntabbable',\r\n\r\n\r\n      /** Save the existing tabindex value and make the node untabbable and unfocusable */\r\n      value: function ensureUntabbable() {\r\n        if (this.node.nodeType !== Node.ELEMENT_NODE) {\r\n          return;\r\n        }\r\n        var element = /** @type {!Element} */this.node;\r\n        if (matches.call(element, _focusableElementsString)) {\r\n          if ( /** @type {!HTMLElement} */element.tabIndex === -1 && this.hasSavedTabIndex) {\r\n            return;\r\n          }\r\n\r\n          if (element.hasAttribute('tabindex')) {\r\n            this._savedTabIndex = /** @type {!HTMLElement} */element.tabIndex;\r\n          }\r\n          element.setAttribute('tabindex', '-1');\r\n          if (element.nodeType === Node.ELEMENT_NODE) {\r\n            element.focus = function () {};\r\n            this._overrodeFocusMethod = true;\r\n          }\r\n        } else if (element.hasAttribute('tabindex')) {\r\n          this._savedTabIndex = /** @type {!HTMLElement} */element.tabIndex;\r\n          element.removeAttribute('tabindex');\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Add another inert root to this inert node's set of managing inert roots.\r\n       * @param {!InertRoot} inertRoot\r\n       */\r\n\r\n    }, {\r\n      key: 'addInertRoot',\r\n      value: function addInertRoot(inertRoot) {\r\n        this._throwIfDestroyed();\r\n        this._inertRoots.add(inertRoot);\r\n      }\r\n\r\n      /**\r\n       * Remove the given inert root from this inert node's set of managing inert roots.\r\n       * If the set of managing inert roots becomes empty, this node is no longer inert,\r\n       * so the object should be destroyed.\r\n       * @param {!InertRoot} inertRoot\r\n       */\r\n\r\n    }, {\r\n      key: 'removeInertRoot',\r\n      value: function removeInertRoot(inertRoot) {\r\n        this._throwIfDestroyed();\r\n        this._inertRoots['delete'](inertRoot);\r\n        if (this._inertRoots.size === 0) {\r\n          this.destructor();\r\n        }\r\n      }\r\n    }, {\r\n      key: 'destroyed',\r\n      get: function get() {\r\n        return (/** @type {!InertNode} */this._destroyed\r\n        );\r\n      }\r\n    }, {\r\n      key: 'hasSavedTabIndex',\r\n      get: function get() {\r\n        return this._savedTabIndex !== null;\r\n      }\r\n\r\n      /** @return {!Node} */\r\n\r\n    }, {\r\n      key: 'node',\r\n      get: function get() {\r\n        this._throwIfDestroyed();\r\n        return this._node;\r\n      }\r\n\r\n      /** @param {?number} tabIndex */\r\n\r\n    }, {\r\n      key: 'savedTabIndex',\r\n      set: function set(tabIndex) {\r\n        this._throwIfDestroyed();\r\n        this._savedTabIndex = tabIndex;\r\n      }\r\n\r\n      /** @return {?number} */\r\n      ,\r\n      get: function get() {\r\n        this._throwIfDestroyed();\r\n        return this._savedTabIndex;\r\n      }\r\n    }]);\r\n\r\n    return InertNode;\r\n  }();\r\n\r\n  /**\r\n   * InertManager is a per-document singleton object which manages all inert roots and nodes.\r\n   *\r\n   * When an element becomes an inert root by having an `inert` attribute set and/or its `inert`\r\n   * property set to `true`, the `setInert` method creates an `InertRoot` object for the element.\r\n   * The `InertRoot` in turn registers itself as managing all of the element's focusable descendant\r\n   * nodes via the `register()` method. The `InertManager` ensures that a single `InertNode` instance\r\n   * is created for each such node, via the `_managedNodes` map.\r\n   */\r\n\r\n\r\n  var InertManager = function () {\r\n    /**\r\n     * @param {!Document} document\r\n     */\r\n    function InertManager(document) {\r\n      _classCallCheck(this, InertManager);\r\n\r\n      if (!document) {\r\n        throw new Error('Missing required argument; InertManager needs to wrap a document.');\r\n      }\r\n\r\n      /** @type {!Document} */\r\n      this._document = document;\r\n\r\n      /**\r\n       * All managed nodes known to this InertManager. In a map to allow looking up by Node.\r\n       * @type {!Map<!Node, !InertNode>}\r\n       */\r\n      this._managedNodes = new Map();\r\n\r\n      /**\r\n       * All inert roots known to this InertManager. In a map to allow looking up by Node.\r\n       * @type {!Map<!Node, !InertRoot>}\r\n       */\r\n      this._inertRoots = new Map();\r\n\r\n      /**\r\n       * Observer for mutations on `document.body`.\r\n       * @type {!MutationObserver}\r\n       */\r\n      this._observer = new MutationObserver(this._watchForInert.bind(this));\r\n\r\n      // Add inert style.\r\n      addInertStyle(document.head || document.body || document.documentElement);\r\n\r\n      // Wait for document to be loaded.\r\n      if (document.readyState === 'loading') {\r\n        document.addEventListener('DOMContentLoaded', this._onDocumentLoaded.bind(this));\r\n      } else {\r\n        this._onDocumentLoaded();\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Set whether the given element should be an inert root or not.\r\n     * @param {!Element} root\r\n     * @param {boolean} inert\r\n     */\r\n\r\n\r\n    _createClass(InertManager, [{\r\n      key: 'setInert',\r\n      value: function setInert(root, inert) {\r\n        if (inert) {\r\n          if (this._inertRoots.has(root)) {\r\n            // element is already inert\r\n            return;\r\n          }\r\n\r\n          var inertRoot = new InertRoot(root, this);\r\n          root.setAttribute('inert', '');\r\n          this._inertRoots.set(root, inertRoot);\r\n          // If not contained in the document, it must be in a shadowRoot.\r\n          // Ensure inert styles are added there.\r\n          if (!this._document.body.contains(root)) {\r\n            var parent = root.parentNode;\r\n            while (parent) {\r\n              if (parent.nodeType === 11) {\r\n                addInertStyle(parent);\r\n              }\r\n              parent = parent.parentNode;\r\n            }\r\n          }\r\n        } else {\r\n          if (!this._inertRoots.has(root)) {\r\n            // element is already non-inert\r\n            return;\r\n          }\r\n\r\n          var _inertRoot = this._inertRoots.get(root);\r\n          _inertRoot.destructor();\r\n          this._inertRoots['delete'](root);\r\n          root.removeAttribute('inert');\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Get the InertRoot object corresponding to the given inert root element, if any.\r\n       * @param {!Node} element\r\n       * @return {!InertRoot|undefined}\r\n       */\r\n\r\n    }, {\r\n      key: 'getInertRoot',\r\n      value: function getInertRoot(element) {\r\n        return this._inertRoots.get(element);\r\n      }\r\n\r\n      /**\r\n       * Register the given InertRoot as managing the given node.\r\n       * In the case where the node has a previously existing inert root, this inert root will\r\n       * be added to its set of inert roots.\r\n       * @param {!Node} node\r\n       * @param {!InertRoot} inertRoot\r\n       * @return {!InertNode} inertNode\r\n       */\r\n\r\n    }, {\r\n      key: 'register',\r\n      value: function register(node, inertRoot) {\r\n        var inertNode = this._managedNodes.get(node);\r\n        if (inertNode !== undefined) {\r\n          // node was already in an inert subtree\r\n          inertNode.addInertRoot(inertRoot);\r\n        } else {\r\n          inertNode = new InertNode(node, inertRoot);\r\n        }\r\n\r\n        this._managedNodes.set(node, inertNode);\r\n\r\n        return inertNode;\r\n      }\r\n\r\n      /**\r\n       * De-register the given InertRoot as managing the given inert node.\r\n       * Removes the inert root from the InertNode's set of managing inert roots, and remove the inert\r\n       * node from the InertManager's set of managed nodes if it is destroyed.\r\n       * If the node is not currently managed, this is essentially a no-op.\r\n       * @param {!Node} node\r\n       * @param {!InertRoot} inertRoot\r\n       * @return {?InertNode} The potentially destroyed InertNode associated with this node, if any.\r\n       */\r\n\r\n    }, {\r\n      key: 'deregister',\r\n      value: function deregister(node, inertRoot) {\r\n        var inertNode = this._managedNodes.get(node);\r\n        if (!inertNode) {\r\n          return null;\r\n        }\r\n\r\n        inertNode.removeInertRoot(inertRoot);\r\n        if (inertNode.destroyed) {\r\n          this._managedNodes['delete'](node);\r\n        }\r\n\r\n        return inertNode;\r\n      }\r\n\r\n      /**\r\n       * Callback used when document has finished loading.\r\n       */\r\n\r\n    }, {\r\n      key: '_onDocumentLoaded',\r\n      value: function _onDocumentLoaded() {\r\n        // Find all inert roots in document and make them actually inert.\r\n        var inertElements = slice.call(this._document.querySelectorAll('[inert]'));\r\n        inertElements.forEach(function (inertElement) {\r\n          this.setInert(inertElement, true);\r\n        }, this);\r\n\r\n        // Comment this out to use programmatic API only.\r\n        this._observer.observe(this._document.body || this._document.documentElement, { attributes: true, subtree: true, childList: true });\r\n      }\r\n\r\n      /**\r\n       * Callback used when mutation observer detects attribute changes.\r\n       * @param {!Array<!MutationRecord>} records\r\n       * @param {!MutationObserver} self\r\n       */\r\n\r\n    }, {\r\n      key: '_watchForInert',\r\n      value: function _watchForInert(records, self) {\r\n        var _this = this;\r\n        records.forEach(function (record) {\r\n          switch (record.type) {\r\n            case 'childList':\r\n              slice.call(record.addedNodes).forEach(function (node) {\r\n                if (node.nodeType !== Node.ELEMENT_NODE) {\r\n                  return;\r\n                }\r\n                var inertElements = slice.call(node.querySelectorAll('[inert]'));\r\n                if (matches.call(node, '[inert]')) {\r\n                  inertElements.unshift(node);\r\n                }\r\n                inertElements.forEach(function (inertElement) {\r\n                  this.setInert(inertElement, true);\r\n                }, _this);\r\n              }, _this);\r\n              break;\r\n            case 'attributes':\r\n              if (record.attributeName !== 'inert') {\r\n                return;\r\n              }\r\n              var target = /** @type {!Element} */record.target;\r\n              var inert = target.hasAttribute('inert');\r\n              _this.setInert(target, inert);\r\n              break;\r\n          }\r\n        }, this);\r\n      }\r\n    }]);\r\n\r\n    return InertManager;\r\n  }();\r\n\r\n  /**\r\n   * Recursively walk the composed tree from |node|.\r\n   * @param {!Node} node\r\n   * @param {(function (!Element))=} callback Callback to be called for each element traversed,\r\n   *     before descending into child nodes.\r\n   * @param {?ShadowRoot=} shadowRootAncestor The nearest ShadowRoot ancestor, if any.\r\n   */\r\n\r\n\r\n  function composedTreeWalk(node, callback, shadowRootAncestor) {\r\n    if (node.nodeType == Node.ELEMENT_NODE) {\r\n      var element = /** @type {!Element} */node;\r\n      if (callback) {\r\n        callback(element);\r\n      }\r\n\r\n      // Descend into node:\r\n      // If it has a ShadowRoot, ignore all child elements - these will be picked\r\n      // up by the <content> or <shadow> elements. Descend straight into the\r\n      // ShadowRoot.\r\n      var shadowRoot = /** @type {!HTMLElement} */element.shadowRoot;\r\n      if (shadowRoot) {\r\n        composedTreeWalk(shadowRoot, callback, shadowRoot);\r\n        return;\r\n      }\r\n\r\n      // If it is a <content> element, descend into distributed elements - these\r\n      // are elements from outside the shadow root which are rendered inside the\r\n      // shadow DOM.\r\n      if (element.localName == 'content') {\r\n        var content = /** @type {!HTMLContentElement} */element;\r\n        // Verifies if ShadowDom v0 is supported.\r\n        var distributedNodes = content.getDistributedNodes ? content.getDistributedNodes() : [];\r\n        for (var i = 0; i < distributedNodes.length; i++) {\r\n          composedTreeWalk(distributedNodes[i], callback, shadowRootAncestor);\r\n        }\r\n        return;\r\n      }\r\n\r\n      // If it is a <slot> element, descend into assigned nodes - these\r\n      // are elements from outside the shadow root which are rendered inside the\r\n      // shadow DOM.\r\n      if (element.localName == 'slot') {\r\n        var slot = /** @type {!HTMLSlotElement} */element;\r\n        // Verify if ShadowDom v1 is supported.\r\n        var _distributedNodes = slot.assignedNodes ? slot.assignedNodes({ flatten: true }) : [];\r\n        for (var _i = 0; _i < _distributedNodes.length; _i++) {\r\n          composedTreeWalk(_distributedNodes[_i], callback, shadowRootAncestor);\r\n        }\r\n        return;\r\n      }\r\n    }\r\n\r\n    // If it is neither the parent of a ShadowRoot, a <content> element, a <slot>\r\n    // element, nor a <shadow> element recurse normally.\r\n    var child = node.firstChild;\r\n    while (child != null) {\r\n      composedTreeWalk(child, callback, shadowRootAncestor);\r\n      child = child.nextSibling;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Adds a style element to the node containing the inert specific styles\r\n   * @param {!Node} node\r\n   */\r\n  function addInertStyle(node) {\r\n    if (node.querySelector('style#inert-style, link#inert-style')) {\r\n      return;\r\n    }\r\n    var style = document.createElement('style');\r\n    style.setAttribute('id', 'inert-style');\r\n    style.textContent = '\\n' + '[inert] {\\n' + '  pointer-events: none;\\n' + '  cursor: default;\\n' + '}\\n' + '\\n' + '[inert], [inert] * {\\n' + '  -webkit-user-select: none;\\n' + '  -moz-user-select: none;\\n' + '  -ms-user-select: none;\\n' + '  user-select: none;\\n' + '}\\n';\r\n    node.appendChild(style);\r\n  }\r\n\r\n  if (!Element.prototype.hasOwnProperty('inert')) {\r\n    /** @type {!InertManager} */\r\n    var inertManager = new InertManager(document);\r\n\r\n    Object.defineProperty(Element.prototype, 'inert', {\r\n      enumerable: true,\r\n      /** @this {!Element} */\r\n      get: function get() {\r\n        return this.hasAttribute('inert');\r\n      },\r\n      /** @this {!Element} */\r\n      set: function set(inert) {\r\n        inertManager.setInert(this, inert);\r\n      }\r\n    });\r\n  }\r\n})();\r\n"]},"metadata":{},"sourceType":"script"}