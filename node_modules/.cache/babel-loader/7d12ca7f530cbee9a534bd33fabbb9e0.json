{"ast":null,"code":"'use strict';\n\nmodule.exports = qsharp;\nqsharp.displayName = 'qsharp';\nqsharp.aliases = ['qs'];\n\nfunction qsharp(Prism) {\n  ;\n\n  (function (Prism) {\n    /**\r\n     * Replaces all placeholders \"<<n>>\" of given pattern with the n-th replacement (zero based).\r\n     *\r\n     * Note: This is a simple text based replacement. Be careful when using backreferences!\r\n     *\r\n     * @param {string} pattern the given pattern.\r\n     * @param {string[]} replacements a list of replacement which can be inserted into the given pattern.\r\n     * @returns {string} the pattern with all placeholders replaced with their corresponding replacements.\r\n     * @example replace(/a<<0>>a/.source, [/b+/.source]) === /a(?:b+)a/.source\r\n     */\n    function replace(pattern, replacements) {\n      return pattern.replace(/<<(\\d+)>>/g, function (m, index) {\n        return '(?:' + replacements[+index] + ')';\n      });\n    }\n    /**\r\n     * @param {string} pattern\r\n     * @param {string[]} replacements\r\n     * @param {string} [flags]\r\n     * @returns {RegExp}\r\n     */\n\n\n    function re(pattern, replacements, flags) {\n      return RegExp(replace(pattern, replacements), flags || '');\n    }\n    /**\r\n     * Creates a nested pattern where all occurrences of the string `<<self>>` are replaced with the pattern itself.\r\n     *\r\n     * @param {string} pattern\r\n     * @param {number} depthLog2\r\n     * @returns {string}\r\n     */\n\n\n    function nested(pattern, depthLog2) {\n      for (var i = 0; i < depthLog2; i++) {\n        pattern = pattern.replace(/<<self>>/g, function () {\n          return '(?:' + pattern + ')';\n        });\n      }\n\n      return pattern.replace(/<<self>>/g, '[^\\\\s\\\\S]');\n    } // https://docs.microsoft.com/en-us/azure/quantum/user-guide/language/typesystem/\n    // https://github.com/microsoft/qsharp-language/tree/main/Specifications/Language/5_Grammar\n\n\n    var keywordKinds = {\n      // keywords which represent a return or variable type\n      type: 'Adj BigInt Bool Ctl Double false Int One Pauli PauliI PauliX PauliY PauliZ Qubit Range Result String true Unit Zero',\n      // all other keywords\n      other: 'Adjoint adjoint apply as auto body borrow borrowing Controlled controlled distribute elif else fail fixup for function if in internal intrinsic invert is let mutable namespace new newtype open operation repeat return self set until use using while within'\n    }; // keywords\n\n    function keywordsToPattern(words) {\n      return '\\\\b(?:' + words.trim().replace(/ /g, '|') + ')\\\\b';\n    }\n\n    var keywords = RegExp(keywordsToPattern(keywordKinds.type + ' ' + keywordKinds.other)); // types\n\n    var identifier = /\\b[A-Za-z_]\\w*\\b/.source;\n    var qualifiedName = replace(/<<0>>(?:\\s*\\.\\s*<<0>>)*/.source, [identifier]);\n    var typeInside = {\n      keyword: keywords,\n      punctuation: /[<>()?,.:[\\]]/\n    }; // strings\n\n    var regularString = /\"(?:\\\\.|[^\\\\\"])*\"/.source;\n    Prism.languages.qsharp = Prism.languages.extend('clike', {\n      comment: /\\/\\/.*/,\n      string: [{\n        pattern: re(/(^|[^$\\\\])<<0>>/.source, [regularString]),\n        lookbehind: true,\n        greedy: true\n      }],\n      'class-name': [{\n        // open Microsoft.Quantum.Canon;\n        // open Microsoft.Quantum.Canon as CN;\n        pattern: re(/(\\b(?:as|open)\\s+)<<0>>(?=\\s*(?:;|as\\b))/.source, [qualifiedName]),\n        lookbehind: true,\n        inside: typeInside\n      }, {\n        // namespace Quantum.App1;\n        pattern: re(/(\\bnamespace\\s+)<<0>>(?=\\s*\\{)/.source, [qualifiedName]),\n        lookbehind: true,\n        inside: typeInside\n      }],\n      keyword: keywords,\n      number: /(?:\\b0(?:x[\\da-f]+|b[01]+|o[0-7]+)|(?:\\B\\.\\d+|\\b\\d+(?:\\.\\d*)?)(?:e[-+]?\\d+)?)l?\\b/i,\n      operator: /\\band=|\\bor=|\\band\\b|\\bor\\b|\\bnot\\b|<[-=]|[-=]>|>>>=?|<<<=?|\\^\\^\\^=?|\\|\\|\\|=?|&&&=?|w\\/=?|~~~|[*\\/+\\-^=!%]=?/,\n      punctuation: /::|[{}[\\];(),.:]/\n    });\n    Prism.languages.insertBefore('qsharp', 'number', {\n      range: {\n        pattern: /\\.\\./,\n        alias: 'operator'\n      }\n    }); // single line\n\n    var interpolationExpr = nested(replace(/\\{(?:[^\"{}]|<<0>>|<<self>>)*\\}/.source, [regularString]), 2);\n    Prism.languages.insertBefore('qsharp', 'string', {\n      'interpolation-string': {\n        pattern: re(/\\$\"(?:\\\\.|<<0>>|[^\\\\\"{])*\"/.source, [interpolationExpr]),\n        greedy: true,\n        inside: {\n          interpolation: {\n            pattern: re(/((?:^|[^\\\\])(?:\\\\\\\\)*)<<0>>/.source, [interpolationExpr]),\n            lookbehind: true,\n            inside: {\n              punctuation: /^\\{|\\}$/,\n              expression: {\n                pattern: /[\\s\\S]+/,\n                alias: 'language-qsharp',\n                inside: Prism.languages.qsharp\n              }\n            }\n          },\n          string: /[\\s\\S]+/\n        }\n      }\n    });\n  })(Prism);\n\n  Prism.languages.qs = Prism.languages.qsharp;\n}","map":{"version":3,"sources":["D:/Rnd/sleepyowl/node_modules/refractor/lang/qsharp.js"],"names":["module","exports","qsharp","displayName","aliases","Prism","replace","pattern","replacements","m","index","re","flags","RegExp","nested","depthLog2","i","keywordKinds","type","other","keywordsToPattern","words","trim","keywords","identifier","source","qualifiedName","typeInside","keyword","punctuation","regularString","languages","extend","comment","string","lookbehind","greedy","inside","number","operator","insertBefore","range","alias","interpolationExpr","interpolation","expression","qs"],"mappings":"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","sourcesContent":["'use strict'\r\n\r\nmodule.exports = qsharp\r\nqsharp.displayName = 'qsharp'\r\nqsharp.aliases = ['qs']\r\nfunction qsharp(Prism) {\r\n  ;(function (Prism) {\r\n    /**\r\n     * Replaces all placeholders \"<<n>>\" of given pattern with the n-th replacement (zero based).\r\n     *\r\n     * Note: This is a simple text based replacement. Be careful when using backreferences!\r\n     *\r\n     * @param {string} pattern the given pattern.\r\n     * @param {string[]} replacements a list of replacement which can be inserted into the given pattern.\r\n     * @returns {string} the pattern with all placeholders replaced with their corresponding replacements.\r\n     * @example replace(/a<<0>>a/.source, [/b+/.source]) === /a(?:b+)a/.source\r\n     */\r\n    function replace(pattern, replacements) {\r\n      return pattern.replace(/<<(\\d+)>>/g, function (m, index) {\r\n        return '(?:' + replacements[+index] + ')'\r\n      })\r\n    }\r\n    /**\r\n     * @param {string} pattern\r\n     * @param {string[]} replacements\r\n     * @param {string} [flags]\r\n     * @returns {RegExp}\r\n     */\r\n    function re(pattern, replacements, flags) {\r\n      return RegExp(replace(pattern, replacements), flags || '')\r\n    }\r\n    /**\r\n     * Creates a nested pattern where all occurrences of the string `<<self>>` are replaced with the pattern itself.\r\n     *\r\n     * @param {string} pattern\r\n     * @param {number} depthLog2\r\n     * @returns {string}\r\n     */\r\n    function nested(pattern, depthLog2) {\r\n      for (var i = 0; i < depthLog2; i++) {\r\n        pattern = pattern.replace(/<<self>>/g, function () {\r\n          return '(?:' + pattern + ')'\r\n        })\r\n      }\r\n      return pattern.replace(/<<self>>/g, '[^\\\\s\\\\S]')\r\n    } // https://docs.microsoft.com/en-us/azure/quantum/user-guide/language/typesystem/\r\n    // https://github.com/microsoft/qsharp-language/tree/main/Specifications/Language/5_Grammar\r\n    var keywordKinds = {\r\n      // keywords which represent a return or variable type\r\n      type: 'Adj BigInt Bool Ctl Double false Int One Pauli PauliI PauliX PauliY PauliZ Qubit Range Result String true Unit Zero',\r\n      // all other keywords\r\n      other:\r\n        'Adjoint adjoint apply as auto body borrow borrowing Controlled controlled distribute elif else fail fixup for function if in internal intrinsic invert is let mutable namespace new newtype open operation repeat return self set until use using while within'\r\n    } // keywords\r\n    function keywordsToPattern(words) {\r\n      return '\\\\b(?:' + words.trim().replace(/ /g, '|') + ')\\\\b'\r\n    }\r\n    var keywords = RegExp(\r\n      keywordsToPattern(keywordKinds.type + ' ' + keywordKinds.other)\r\n    ) // types\r\n    var identifier = /\\b[A-Za-z_]\\w*\\b/.source\r\n    var qualifiedName = replace(/<<0>>(?:\\s*\\.\\s*<<0>>)*/.source, [identifier])\r\n    var typeInside = {\r\n      keyword: keywords,\r\n      punctuation: /[<>()?,.:[\\]]/\r\n    } // strings\r\n    var regularString = /\"(?:\\\\.|[^\\\\\"])*\"/.source\r\n    Prism.languages.qsharp = Prism.languages.extend('clike', {\r\n      comment: /\\/\\/.*/,\r\n      string: [\r\n        {\r\n          pattern: re(/(^|[^$\\\\])<<0>>/.source, [regularString]),\r\n          lookbehind: true,\r\n          greedy: true\r\n        }\r\n      ],\r\n      'class-name': [\r\n        {\r\n          // open Microsoft.Quantum.Canon;\r\n          // open Microsoft.Quantum.Canon as CN;\r\n          pattern: re(/(\\b(?:as|open)\\s+)<<0>>(?=\\s*(?:;|as\\b))/.source, [\r\n            qualifiedName\r\n          ]),\r\n          lookbehind: true,\r\n          inside: typeInside\r\n        },\r\n        {\r\n          // namespace Quantum.App1;\r\n          pattern: re(/(\\bnamespace\\s+)<<0>>(?=\\s*\\{)/.source, [qualifiedName]),\r\n          lookbehind: true,\r\n          inside: typeInside\r\n        }\r\n      ],\r\n      keyword: keywords,\r\n      number:\r\n        /(?:\\b0(?:x[\\da-f]+|b[01]+|o[0-7]+)|(?:\\B\\.\\d+|\\b\\d+(?:\\.\\d*)?)(?:e[-+]?\\d+)?)l?\\b/i,\r\n      operator:\r\n        /\\band=|\\bor=|\\band\\b|\\bor\\b|\\bnot\\b|<[-=]|[-=]>|>>>=?|<<<=?|\\^\\^\\^=?|\\|\\|\\|=?|&&&=?|w\\/=?|~~~|[*\\/+\\-^=!%]=?/,\r\n      punctuation: /::|[{}[\\];(),.:]/\r\n    })\r\n    Prism.languages.insertBefore('qsharp', 'number', {\r\n      range: {\r\n        pattern: /\\.\\./,\r\n        alias: 'operator'\r\n      }\r\n    }) // single line\r\n    var interpolationExpr = nested(\r\n      replace(/\\{(?:[^\"{}]|<<0>>|<<self>>)*\\}/.source, [regularString]),\r\n      2\r\n    )\r\n    Prism.languages.insertBefore('qsharp', 'string', {\r\n      'interpolation-string': {\r\n        pattern: re(/\\$\"(?:\\\\.|<<0>>|[^\\\\\"{])*\"/.source, [interpolationExpr]),\r\n        greedy: true,\r\n        inside: {\r\n          interpolation: {\r\n            pattern: re(/((?:^|[^\\\\])(?:\\\\\\\\)*)<<0>>/.source, [\r\n              interpolationExpr\r\n            ]),\r\n            lookbehind: true,\r\n            inside: {\r\n              punctuation: /^\\{|\\}$/,\r\n              expression: {\r\n                pattern: /[\\s\\S]+/,\r\n                alias: 'language-qsharp',\r\n                inside: Prism.languages.qsharp\r\n              }\r\n            }\r\n          },\r\n          string: /[\\s\\S]+/\r\n        }\r\n      }\r\n    })\r\n  })(Prism)\r\n  Prism.languages.qs = Prism.languages.qsharp\r\n}\r\n"]},"metadata":{},"sourceType":"script"}