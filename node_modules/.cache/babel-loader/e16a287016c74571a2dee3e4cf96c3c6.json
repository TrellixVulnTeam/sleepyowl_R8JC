{"ast":null,"code":"'use strict';\n\nvar refractorCsharp = require('./csharp.js');\n\nmodule.exports = cshtml;\ncshtml.displayName = 'cshtml';\ncshtml.aliases = ['razor'];\n\nfunction cshtml(Prism) {\n  Prism.register(refractorCsharp) // Docs:\n  // https://docs.microsoft.com/en-us/aspnet/core/razor-pages/?view=aspnetcore-5.0&tabs=visual-studio\n  // https://docs.microsoft.com/en-us/aspnet/core/mvc/views/razor?view=aspnetcore-5.0\n  ;\n\n  (function (Prism) {\n    var commentLike = /\\/(?![/*])|\\/\\/.*[\\r\\n]|\\/\\*[^*]*(?:\\*(?!\\/)[^*]*)*\\*\\//.source;\n    var stringLike = /@(?!\")|\"(?:[^\\r\\n\\\\\"]|\\\\.)*\"|@\"(?:[^\\\\\"]|\"\"|\\\\[\\s\\S])*\"(?!\")/.source + '|' + /'(?:(?:[^\\r\\n'\\\\]|\\\\.|\\\\[Uux][\\da-fA-F]{1,8})'|(?=[^\\\\](?!')))/.source;\n    /**\r\n     * Creates a nested pattern where all occurrences of the string `<<self>>` are replaced with the pattern itself.\r\n     *\r\n     * @param {string} pattern\r\n     * @param {number} depthLog2\r\n     * @returns {string}\r\n     */\n\n    function nested(pattern, depthLog2) {\n      for (var i = 0; i < depthLog2; i++) {\n        pattern = pattern.replace(/<self>/g, function () {\n          return '(?:' + pattern + ')';\n        });\n      }\n\n      return pattern.replace(/<self>/g, '[^\\\\s\\\\S]').replace(/<str>/g, '(?:' + stringLike + ')').replace(/<comment>/g, '(?:' + commentLike + ')');\n    }\n\n    var round = nested(/\\((?:[^()'\"@/]|<str>|<comment>|<self>)*\\)/.source, 2);\n    var square = nested(/\\[(?:[^\\[\\]'\"@/]|<str>|<comment>|<self>)*\\]/.source, 2);\n    var curly = nested(/\\{(?:[^{}'\"@/]|<str>|<comment>|<self>)*\\}/.source, 2);\n    var angle = nested(/<(?:[^<>'\"@/]|<str>|<comment>|<self>)*>/.source, 2); // Note about the above bracket patterns:\n    // They all ignore HTML expressions that might be in the C# code. This is a problem because HTML (like strings and\n    // comments) is parsed differently. This is a huge problem because HTML might contain brackets and quotes which\n    // messes up the bracket and string counting implemented by the above patterns.\n    //\n    // This problem is not fixable because 1) HTML expression are highly context sensitive and very difficult to detect\n    // and 2) they require one capturing group at every nested level. See the `tagRegion` pattern to admire the\n    // complexity of an HTML expression.\n    //\n    // To somewhat alleviate the problem a bit, the patterns for characters (e.g. 'a') is very permissive, it also\n    // allows invalid characters to support HTML expressions like this: <p>That's it!</p>.\n\n    var tagAttrs = /(?:\\s(?:\\s*[^\\s>\\/=]+(?:\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+(?=[\\s>]))|(?=[\\s/>])))+)?/.source;\n    var tagContent = /(?!\\d)[^\\s>\\/=$<%]+/.source + tagAttrs + /\\s*\\/?>/.source;\n    var tagRegion = /\\B@?/.source + '(?:' + /<([a-zA-Z][\\w:]*)/.source + tagAttrs + /\\s*>/.source + '(?:' + (/[^<]/.source + '|' + // all tags that are not the start tag\n    // eslint-disable-next-line regexp/strict\n    /<\\/?(?!\\1\\b)/.source + tagContent + '|' + // nested start tag\n    nested( // eslint-disable-next-line regexp/strict\n    /<\\1/.source + tagAttrs + /\\s*>/.source + '(?:' + (/[^<]/.source + '|' + // all tags that are not the start tag\n    // eslint-disable-next-line regexp/strict\n    /<\\/?(?!\\1\\b)/.source + tagContent + '|' + '<self>') + ')*' + // eslint-disable-next-line regexp/strict\n    /<\\/\\1\\s*>/.source, 2)) + ')*' + // eslint-disable-next-line regexp/strict\n    /<\\/\\1\\s*>/.source + '|' + /</.source + tagContent + ')'; // Now for the actual language definition(s):\n    //\n    // Razor as a language has 2 parts:\n    //  1) CSHTML: A markup-like language that has been extended with inline C# code expressions and blocks.\n    //  2) C#+HTML: A variant of C# that can contain CSHTML tags as expressions.\n    //\n    // In the below code, both CSHTML and C#+HTML will be create as separate language definitions that reference each\n    // other. However, only CSHTML will be exported via `Prism.languages`.\n\n    Prism.languages.cshtml = Prism.languages.extend('markup', {});\n    var csharpWithHtml = Prism.languages.insertBefore('csharp', 'string', {\n      html: {\n        pattern: RegExp(tagRegion),\n        greedy: true,\n        inside: Prism.languages.cshtml\n      }\n    }, {\n      csharp: Prism.languages.extend('csharp', {})\n    });\n    var cs = {\n      pattern: /\\S[\\s\\S]*/,\n      alias: 'language-csharp',\n      inside: csharpWithHtml\n    };\n    Prism.languages.insertBefore('cshtml', 'prolog', {\n      'razor-comment': {\n        pattern: /@\\*[\\s\\S]*?\\*@/,\n        greedy: true,\n        alias: 'comment'\n      },\n      block: {\n        pattern: RegExp(/(^|[^@])@/.source + '(?:' + [// @{ ... }\n        curly, // @code{ ... }\n        /(?:code|functions)\\s*/.source + curly, // @for (...) { ... }\n        /(?:for|foreach|lock|switch|using|while)\\s*/.source + round + /\\s*/.source + curly, // @do { ... } while (...);\n        /do\\s*/.source + curly + /\\s*while\\s*/.source + round + /(?:\\s*;)?/.source, // @try { ... } catch (...) { ... } finally { ... }\n        /try\\s*/.source + curly + /\\s*catch\\s*/.source + round + /\\s*/.source + curly + /\\s*finally\\s*/.source + curly, // @if (...) {...} else if (...) {...} else {...}\n        /if\\s*/.source + round + /\\s*/.source + curly + '(?:' + /\\s*else/.source + '(?:' + /\\s+if\\s*/.source + round + ')?' + /\\s*/.source + curly + ')*'].join('|') + ')'),\n        lookbehind: true,\n        greedy: true,\n        inside: {\n          keyword: /^@\\w*/,\n          csharp: cs\n        }\n      },\n      directive: {\n        pattern: /^([ \\t]*)@(?:addTagHelper|attribute|implements|inherits|inject|layout|model|namespace|page|preservewhitespace|removeTagHelper|section|tagHelperPrefix|using)(?=\\s).*/m,\n        lookbehind: true,\n        greedy: true,\n        inside: {\n          keyword: /^@\\w+/,\n          csharp: cs\n        }\n      },\n      value: {\n        pattern: RegExp(/(^|[^@])@/.source + /(?:await\\b\\s*)?/.source + '(?:' + /\\w+\\b/.source + '|' + round + ')' + '(?:' + /[?!]?\\.\\w+\\b/.source + '|' + round + '|' + square + '|' + angle + round + ')*'),\n        lookbehind: true,\n        greedy: true,\n        alias: 'variable',\n        inside: {\n          keyword: /^@/,\n          csharp: cs\n        }\n      },\n      'delegate-operator': {\n        pattern: /(^|[^@])@(?=<)/,\n        lookbehind: true,\n        alias: 'operator'\n      }\n    });\n    Prism.languages.razor = Prism.languages.cshtml;\n  })(Prism);\n}","map":{"version":3,"sources":["D:/Rnd/sleepyowl/node_modules/refractor/lang/cshtml.js"],"names":["refractorCsharp","require","module","exports","cshtml","displayName","aliases","Prism","register","commentLike","source","stringLike","nested","pattern","depthLog2","i","replace","round","square","curly","angle","tagAttrs","tagContent","tagRegion","languages","extend","csharpWithHtml","insertBefore","html","RegExp","greedy","inside","csharp","cs","alias","block","join","lookbehind","keyword","directive","value","razor"],"mappings":"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","sourcesContent":["'use strict'\r\nvar refractorCsharp = require('./csharp.js')\r\nmodule.exports = cshtml\r\ncshtml.displayName = 'cshtml'\r\ncshtml.aliases = ['razor']\r\nfunction cshtml(Prism) {\r\n  Prism.register(refractorCsharp)\r\n  // Docs:\r\n  // https://docs.microsoft.com/en-us/aspnet/core/razor-pages/?view=aspnetcore-5.0&tabs=visual-studio\r\n  // https://docs.microsoft.com/en-us/aspnet/core/mvc/views/razor?view=aspnetcore-5.0\r\n  ;(function (Prism) {\r\n    var commentLike = /\\/(?![/*])|\\/\\/.*[\\r\\n]|\\/\\*[^*]*(?:\\*(?!\\/)[^*]*)*\\*\\//\r\n      .source\r\n    var stringLike =\r\n      /@(?!\")|\"(?:[^\\r\\n\\\\\"]|\\\\.)*\"|@\"(?:[^\\\\\"]|\"\"|\\\\[\\s\\S])*\"(?!\")/.source +\r\n      '|' +\r\n      /'(?:(?:[^\\r\\n'\\\\]|\\\\.|\\\\[Uux][\\da-fA-F]{1,8})'|(?=[^\\\\](?!')))/.source\r\n    /**\r\n     * Creates a nested pattern where all occurrences of the string `<<self>>` are replaced with the pattern itself.\r\n     *\r\n     * @param {string} pattern\r\n     * @param {number} depthLog2\r\n     * @returns {string}\r\n     */\r\n    function nested(pattern, depthLog2) {\r\n      for (var i = 0; i < depthLog2; i++) {\r\n        pattern = pattern.replace(/<self>/g, function () {\r\n          return '(?:' + pattern + ')'\r\n        })\r\n      }\r\n      return pattern\r\n        .replace(/<self>/g, '[^\\\\s\\\\S]')\r\n        .replace(/<str>/g, '(?:' + stringLike + ')')\r\n        .replace(/<comment>/g, '(?:' + commentLike + ')')\r\n    }\r\n    var round = nested(/\\((?:[^()'\"@/]|<str>|<comment>|<self>)*\\)/.source, 2)\r\n    var square = nested(/\\[(?:[^\\[\\]'\"@/]|<str>|<comment>|<self>)*\\]/.source, 2)\r\n    var curly = nested(/\\{(?:[^{}'\"@/]|<str>|<comment>|<self>)*\\}/.source, 2)\r\n    var angle = nested(/<(?:[^<>'\"@/]|<str>|<comment>|<self>)*>/.source, 2) // Note about the above bracket patterns:\r\n    // They all ignore HTML expressions that might be in the C# code. This is a problem because HTML (like strings and\r\n    // comments) is parsed differently. This is a huge problem because HTML might contain brackets and quotes which\r\n    // messes up the bracket and string counting implemented by the above patterns.\r\n    //\r\n    // This problem is not fixable because 1) HTML expression are highly context sensitive and very difficult to detect\r\n    // and 2) they require one capturing group at every nested level. See the `tagRegion` pattern to admire the\r\n    // complexity of an HTML expression.\r\n    //\r\n    // To somewhat alleviate the problem a bit, the patterns for characters (e.g. 'a') is very permissive, it also\r\n    // allows invalid characters to support HTML expressions like this: <p>That's it!</p>.\r\n    var tagAttrs =\r\n      /(?:\\s(?:\\s*[^\\s>\\/=]+(?:\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+(?=[\\s>]))|(?=[\\s/>])))+)?/\r\n        .source\r\n    var tagContent = /(?!\\d)[^\\s>\\/=$<%]+/.source + tagAttrs + /\\s*\\/?>/.source\r\n    var tagRegion =\r\n      /\\B@?/.source +\r\n      '(?:' +\r\n      /<([a-zA-Z][\\w:]*)/.source +\r\n      tagAttrs +\r\n      /\\s*>/.source +\r\n      '(?:' +\r\n      (/[^<]/.source +\r\n        '|' + // all tags that are not the start tag\r\n        // eslint-disable-next-line regexp/strict\r\n        /<\\/?(?!\\1\\b)/.source +\r\n        tagContent +\r\n        '|' + // nested start tag\r\n        nested(\r\n          // eslint-disable-next-line regexp/strict\r\n          /<\\1/.source +\r\n            tagAttrs +\r\n            /\\s*>/.source +\r\n            '(?:' +\r\n            (/[^<]/.source +\r\n              '|' + // all tags that are not the start tag\r\n              // eslint-disable-next-line regexp/strict\r\n              /<\\/?(?!\\1\\b)/.source +\r\n              tagContent +\r\n              '|' +\r\n              '<self>') +\r\n            ')*' + // eslint-disable-next-line regexp/strict\r\n            /<\\/\\1\\s*>/.source,\r\n          2\r\n        )) +\r\n      ')*' + // eslint-disable-next-line regexp/strict\r\n      /<\\/\\1\\s*>/.source +\r\n      '|' +\r\n      /</.source +\r\n      tagContent +\r\n      ')' // Now for the actual language definition(s):\r\n    //\r\n    // Razor as a language has 2 parts:\r\n    //  1) CSHTML: A markup-like language that has been extended with inline C# code expressions and blocks.\r\n    //  2) C#+HTML: A variant of C# that can contain CSHTML tags as expressions.\r\n    //\r\n    // In the below code, both CSHTML and C#+HTML will be create as separate language definitions that reference each\r\n    // other. However, only CSHTML will be exported via `Prism.languages`.\r\n    Prism.languages.cshtml = Prism.languages.extend('markup', {})\r\n    var csharpWithHtml = Prism.languages.insertBefore(\r\n      'csharp',\r\n      'string',\r\n      {\r\n        html: {\r\n          pattern: RegExp(tagRegion),\r\n          greedy: true,\r\n          inside: Prism.languages.cshtml\r\n        }\r\n      },\r\n      {\r\n        csharp: Prism.languages.extend('csharp', {})\r\n      }\r\n    )\r\n    var cs = {\r\n      pattern: /\\S[\\s\\S]*/,\r\n      alias: 'language-csharp',\r\n      inside: csharpWithHtml\r\n    }\r\n    Prism.languages.insertBefore('cshtml', 'prolog', {\r\n      'razor-comment': {\r\n        pattern: /@\\*[\\s\\S]*?\\*@/,\r\n        greedy: true,\r\n        alias: 'comment'\r\n      },\r\n      block: {\r\n        pattern: RegExp(\r\n          /(^|[^@])@/.source +\r\n            '(?:' +\r\n            [\r\n              // @{ ... }\r\n              curly, // @code{ ... }\r\n              /(?:code|functions)\\s*/.source + curly, // @for (...) { ... }\r\n              /(?:for|foreach|lock|switch|using|while)\\s*/.source +\r\n                round +\r\n                /\\s*/.source +\r\n                curly, // @do { ... } while (...);\r\n              /do\\s*/.source +\r\n                curly +\r\n                /\\s*while\\s*/.source +\r\n                round +\r\n                /(?:\\s*;)?/.source, // @try { ... } catch (...) { ... } finally { ... }\r\n              /try\\s*/.source +\r\n                curly +\r\n                /\\s*catch\\s*/.source +\r\n                round +\r\n                /\\s*/.source +\r\n                curly +\r\n                /\\s*finally\\s*/.source +\r\n                curly, // @if (...) {...} else if (...) {...} else {...}\r\n              /if\\s*/.source +\r\n                round +\r\n                /\\s*/.source +\r\n                curly +\r\n                '(?:' +\r\n                /\\s*else/.source +\r\n                '(?:' +\r\n                /\\s+if\\s*/.source +\r\n                round +\r\n                ')?' +\r\n                /\\s*/.source +\r\n                curly +\r\n                ')*'\r\n            ].join('|') +\r\n            ')'\r\n        ),\r\n        lookbehind: true,\r\n        greedy: true,\r\n        inside: {\r\n          keyword: /^@\\w*/,\r\n          csharp: cs\r\n        }\r\n      },\r\n      directive: {\r\n        pattern:\r\n          /^([ \\t]*)@(?:addTagHelper|attribute|implements|inherits|inject|layout|model|namespace|page|preservewhitespace|removeTagHelper|section|tagHelperPrefix|using)(?=\\s).*/m,\r\n        lookbehind: true,\r\n        greedy: true,\r\n        inside: {\r\n          keyword: /^@\\w+/,\r\n          csharp: cs\r\n        }\r\n      },\r\n      value: {\r\n        pattern: RegExp(\r\n          /(^|[^@])@/.source +\r\n            /(?:await\\b\\s*)?/.source +\r\n            '(?:' +\r\n            /\\w+\\b/.source +\r\n            '|' +\r\n            round +\r\n            ')' +\r\n            '(?:' +\r\n            /[?!]?\\.\\w+\\b/.source +\r\n            '|' +\r\n            round +\r\n            '|' +\r\n            square +\r\n            '|' +\r\n            angle +\r\n            round +\r\n            ')*'\r\n        ),\r\n        lookbehind: true,\r\n        greedy: true,\r\n        alias: 'variable',\r\n        inside: {\r\n          keyword: /^@/,\r\n          csharp: cs\r\n        }\r\n      },\r\n      'delegate-operator': {\r\n        pattern: /(^|[^@])@(?=<)/,\r\n        lookbehind: true,\r\n        alias: 'operator'\r\n      }\r\n    })\r\n    Prism.languages.razor = Prism.languages.cshtml\r\n  })(Prism)\r\n}\r\n"]},"metadata":{},"sourceType":"script"}