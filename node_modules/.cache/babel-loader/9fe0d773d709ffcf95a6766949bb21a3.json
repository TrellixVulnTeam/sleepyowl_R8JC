{"ast":null,"code":"'use strict';\n\nmodule.exports = kumir;\nkumir.displayName = 'kumir';\nkumir.aliases = ['kum'];\n\nfunction kumir(Prism) {\n  /* eslint-disable regexp/no-dupe-characters-character-class */\n  ;\n\n  (function (Prism) {\n    /**\r\n     * Regular expression for characters that are not allowed in identifiers.\r\n     *\r\n     * @type {string}\r\n     */\n    var nonId = /\\s\\x00-\\x1f\\x22-\\x2f\\x3a-\\x3f\\x5b-\\x5e\\x60\\x7b-\\x7e/.source;\n    /**\r\n     * Surround a regular expression for IDs with patterns for non-ID sequences.\r\n     *\r\n     * @param {string} pattern A regular expression for identifiers.\r\n     * @param {string} [flags] The regular expression flags.\r\n     * @returns {RegExp} A wrapped regular expression for identifiers.\r\n     */\n\n    function wrapId(pattern, flags) {\n      return RegExp(pattern.replace(/<nonId>/g, nonId), flags);\n    }\n\n    Prism.languages.kumir = {\n      comment: {\n        pattern: /\\|.*/\n      },\n      prolog: {\n        pattern: /#.*/,\n        greedy: true\n      },\n      string: {\n        pattern: /\"[^\\n\\r\"]*\"|'[^\\n\\r']*'/,\n        greedy: true\n      },\n      boolean: {\n        pattern: wrapId(/(^|[<nonId>])(?:да|нет)(?=[<nonId>]|$)/.source),\n        lookbehind: true\n      },\n      'operator-word': {\n        pattern: wrapId(/(^|[<nonId>])(?:и|или|не)(?=[<nonId>]|$)/.source),\n        lookbehind: true,\n        alias: 'keyword'\n      },\n      'system-variable': {\n        pattern: wrapId(/(^|[<nonId>])знач(?=[<nonId>]|$)/.source),\n        lookbehind: true,\n        alias: 'keyword'\n      },\n      type: [{\n        pattern: wrapId(/(^|[<nonId>])(?:вещ|лит|лог|сим|цел)(?:\\x20*таб)?(?=[<nonId>]|$)/.source),\n        lookbehind: true,\n        alias: 'builtin'\n      }, {\n        pattern: wrapId(/(^|[<nonId>])(?:компл|сканкод|файл|цвет)(?=[<nonId>]|$)/.source),\n        lookbehind: true,\n        alias: 'important'\n      }],\n\n      /**\r\n       * Should be performed after searching for type names because of \"таб\".\r\n       * \"таб\" is a reserved word, but never used without a preceding type name.\r\n       * \"НАЗНАЧИТЬ\", \"Фввод\", and \"Фвывод\" are not reserved words.\r\n       */\n      keyword: {\n        pattern: wrapId(/(^|[<nonId>])(?:алг|арг(?:\\x20*рез)?|ввод|ВКЛЮЧИТЬ|вс[её]|выбор|вывод|выход|дано|для|до|дс|если|иначе|исп|использовать|кон(?:(?:\\x20+|_)исп)?|кц(?:(?:\\x20+|_)при)?|надо|нач|нс|нц|от|пауза|пока|при|раза?|рез|стоп|таб|то|утв|шаг)(?=[<nonId>]|$)/.source),\n        lookbehind: true\n      },\n\n      /** Should be performed after searching for reserved words. */\n      name: {\n        // eslint-disable-next-line regexp/no-super-linear-backtracking\n        pattern: wrapId(/(^|[<nonId>])[^\\d<nonId>][^<nonId>]*(?:\\x20+[^<nonId>]+)*(?=[<nonId>]|$)/.source),\n        lookbehind: true\n      },\n\n      /** Should be performed after searching for names. */\n      number: {\n        pattern: wrapId(/(^|[<nonId>])(?:\\B\\$[\\da-f]+\\b|(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:e[+-]?\\d+)?)(?=[<nonId>]|$)/.source, 'i'),\n        lookbehind: true\n      },\n\n      /** Should be performed after searching for words. */\n      punctuation: /:=|[(),:;\\[\\]]/,\n\n      /**\r\n       * Should be performed after searching for\r\n       * - numeric constants (because of \"+\" and \"-\");\r\n       * - punctuation marks (because of \":=\" and \"=\").\r\n       */\n      'operator-char': {\n        pattern: /\\*\\*?|<[=>]?|>=?|[-+/=]/,\n        alias: 'operator'\n      }\n    };\n    Prism.languages.kum = Prism.languages.kumir;\n  })(Prism);\n}","map":{"version":3,"sources":["D:/Rnd/sleepyowl/node_modules/refractor/lang/kumir.js"],"names":["module","exports","kumir","displayName","aliases","Prism","nonId","source","wrapId","pattern","flags","RegExp","replace","languages","comment","prolog","greedy","string","boolean","lookbehind","alias","type","keyword","name","number","punctuation","kum"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,OAAP,GAAiBC,KAAjB;AACAA,KAAK,CAACC,WAAN,GAAoB,OAApB;AACAD,KAAK,CAACE,OAAN,GAAgB,CAAC,KAAD,CAAhB;;AACA,SAASF,KAAT,CAAeG,KAAf,EAAsB;AACpB;AACA;;AAAC,GAAC,UAAUA,KAAV,EAAiB;AACjB;AACJ;AACA;AACA;AACA;AACI,QAAIC,KAAK,GAAG,sDAAsDC,MAAlE;AACA;AACJ;AACA;AACA;AACA;AACA;AACA;;AACI,aAASC,MAAT,CAAgBC,OAAhB,EAAyBC,KAAzB,EAAgC;AAC9B,aAAOC,MAAM,CAACF,OAAO,CAACG,OAAR,CAAgB,UAAhB,EAA4BN,KAA5B,CAAD,EAAqCI,KAArC,CAAb;AACD;;AACDL,IAAAA,KAAK,CAACQ,SAAN,CAAgBX,KAAhB,GAAwB;AACtBY,MAAAA,OAAO,EAAE;AACPL,QAAAA,OAAO,EAAE;AADF,OADa;AAItBM,MAAAA,MAAM,EAAE;AACNN,QAAAA,OAAO,EAAE,KADH;AAENO,QAAAA,MAAM,EAAE;AAFF,OAJc;AAQtBC,MAAAA,MAAM,EAAE;AACNR,QAAAA,OAAO,EAAE,yBADH;AAENO,QAAAA,MAAM,EAAE;AAFF,OARc;AAYtBE,MAAAA,OAAO,EAAE;AACPT,QAAAA,OAAO,EAAED,MAAM,CAAC,yCAAyCD,MAA1C,CADR;AAEPY,QAAAA,UAAU,EAAE;AAFL,OAZa;AAgBtB,uBAAiB;AACfV,QAAAA,OAAO,EAAED,MAAM,CAAC,2CAA2CD,MAA5C,CADA;AAEfY,QAAAA,UAAU,EAAE,IAFG;AAGfC,QAAAA,KAAK,EAAE;AAHQ,OAhBK;AAqBtB,yBAAmB;AACjBX,QAAAA,OAAO,EAAED,MAAM,CAAC,mCAAmCD,MAApC,CADE;AAEjBY,QAAAA,UAAU,EAAE,IAFK;AAGjBC,QAAAA,KAAK,EAAE;AAHU,OArBG;AA0BtBC,MAAAA,IAAI,EAAE,CACJ;AACEZ,QAAAA,OAAO,EAAED,MAAM,CACb,mEACGD,MAFU,CADjB;AAKEY,QAAAA,UAAU,EAAE,IALd;AAMEC,QAAAA,KAAK,EAAE;AANT,OADI,EASJ;AACEX,QAAAA,OAAO,EAAED,MAAM,CACb,0DAA0DD,MAD7C,CADjB;AAIEY,QAAAA,UAAU,EAAE,IAJd;AAKEC,QAAAA,KAAK,EAAE;AALT,OATI,CA1BgB;;AA2CtB;AACN;AACA;AACA;AACA;AACME,MAAAA,OAAO,EAAE;AACPb,QAAAA,OAAO,EAAED,MAAM,CACb,qPACGD,MAFU,CADR;AAKPY,QAAAA,UAAU,EAAE;AALL,OAhDa;;AAuDtB;AACAI,MAAAA,IAAI,EAAE;AACJ;AACAd,QAAAA,OAAO,EAAED,MAAM,CACb,2EACGD,MAFU,CAFX;AAMJY,QAAAA,UAAU,EAAE;AANR,OAxDgB;;AAgEtB;AACAK,MAAAA,MAAM,EAAE;AACNf,QAAAA,OAAO,EAAED,MAAM,CACb,2FACGD,MAFU,EAGb,GAHa,CADT;AAMNY,QAAAA,UAAU,EAAE;AANN,OAjEc;;AAyEtB;AACAM,MAAAA,WAAW,EAAE,gBA1ES;;AA2EtB;AACN;AACA;AACA;AACA;AACM,uBAAiB;AACfhB,QAAAA,OAAO,EAAE,yBADM;AAEfW,QAAAA,KAAK,EAAE;AAFQ;AAhFK,KAAxB;AAqFAf,IAAAA,KAAK,CAACQ,SAAN,CAAgBa,GAAhB,GAAsBrB,KAAK,CAACQ,SAAN,CAAgBX,KAAtC;AACD,GAvGA,EAuGEG,KAvGF;AAwGF","sourcesContent":["'use strict'\r\n\r\nmodule.exports = kumir\r\nkumir.displayName = 'kumir'\r\nkumir.aliases = ['kum']\r\nfunction kumir(Prism) {\r\n  /* eslint-disable regexp/no-dupe-characters-character-class */\r\n  ;(function (Prism) {\r\n    /**\r\n     * Regular expression for characters that are not allowed in identifiers.\r\n     *\r\n     * @type {string}\r\n     */\r\n    var nonId = /\\s\\x00-\\x1f\\x22-\\x2f\\x3a-\\x3f\\x5b-\\x5e\\x60\\x7b-\\x7e/.source\r\n    /**\r\n     * Surround a regular expression for IDs with patterns for non-ID sequences.\r\n     *\r\n     * @param {string} pattern A regular expression for identifiers.\r\n     * @param {string} [flags] The regular expression flags.\r\n     * @returns {RegExp} A wrapped regular expression for identifiers.\r\n     */\r\n    function wrapId(pattern, flags) {\r\n      return RegExp(pattern.replace(/<nonId>/g, nonId), flags)\r\n    }\r\n    Prism.languages.kumir = {\r\n      comment: {\r\n        pattern: /\\|.*/\r\n      },\r\n      prolog: {\r\n        pattern: /#.*/,\r\n        greedy: true\r\n      },\r\n      string: {\r\n        pattern: /\"[^\\n\\r\"]*\"|'[^\\n\\r']*'/,\r\n        greedy: true\r\n      },\r\n      boolean: {\r\n        pattern: wrapId(/(^|[<nonId>])(?:да|нет)(?=[<nonId>]|$)/.source),\r\n        lookbehind: true\r\n      },\r\n      'operator-word': {\r\n        pattern: wrapId(/(^|[<nonId>])(?:и|или|не)(?=[<nonId>]|$)/.source),\r\n        lookbehind: true,\r\n        alias: 'keyword'\r\n      },\r\n      'system-variable': {\r\n        pattern: wrapId(/(^|[<nonId>])знач(?=[<nonId>]|$)/.source),\r\n        lookbehind: true,\r\n        alias: 'keyword'\r\n      },\r\n      type: [\r\n        {\r\n          pattern: wrapId(\r\n            /(^|[<nonId>])(?:вещ|лит|лог|сим|цел)(?:\\x20*таб)?(?=[<nonId>]|$)/\r\n              .source\r\n          ),\r\n          lookbehind: true,\r\n          alias: 'builtin'\r\n        },\r\n        {\r\n          pattern: wrapId(\r\n            /(^|[<nonId>])(?:компл|сканкод|файл|цвет)(?=[<nonId>]|$)/.source\r\n          ),\r\n          lookbehind: true,\r\n          alias: 'important'\r\n        }\r\n      ],\r\n      /**\r\n       * Should be performed after searching for type names because of \"таб\".\r\n       * \"таб\" is a reserved word, but never used without a preceding type name.\r\n       * \"НАЗНАЧИТЬ\", \"Фввод\", and \"Фвывод\" are not reserved words.\r\n       */\r\n      keyword: {\r\n        pattern: wrapId(\r\n          /(^|[<nonId>])(?:алг|арг(?:\\x20*рез)?|ввод|ВКЛЮЧИТЬ|вс[её]|выбор|вывод|выход|дано|для|до|дс|если|иначе|исп|использовать|кон(?:(?:\\x20+|_)исп)?|кц(?:(?:\\x20+|_)при)?|надо|нач|нс|нц|от|пауза|пока|при|раза?|рез|стоп|таб|то|утв|шаг)(?=[<nonId>]|$)/\r\n            .source\r\n        ),\r\n        lookbehind: true\r\n      },\r\n      /** Should be performed after searching for reserved words. */\r\n      name: {\r\n        // eslint-disable-next-line regexp/no-super-linear-backtracking\r\n        pattern: wrapId(\r\n          /(^|[<nonId>])[^\\d<nonId>][^<nonId>]*(?:\\x20+[^<nonId>]+)*(?=[<nonId>]|$)/\r\n            .source\r\n        ),\r\n        lookbehind: true\r\n      },\r\n      /** Should be performed after searching for names. */\r\n      number: {\r\n        pattern: wrapId(\r\n          /(^|[<nonId>])(?:\\B\\$[\\da-f]+\\b|(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:e[+-]?\\d+)?)(?=[<nonId>]|$)/\r\n            .source,\r\n          'i'\r\n        ),\r\n        lookbehind: true\r\n      },\r\n      /** Should be performed after searching for words. */\r\n      punctuation: /:=|[(),:;\\[\\]]/,\r\n      /**\r\n       * Should be performed after searching for\r\n       * - numeric constants (because of \"+\" and \"-\");\r\n       * - punctuation marks (because of \":=\" and \"=\").\r\n       */\r\n      'operator-char': {\r\n        pattern: /\\*\\*?|<[=>]?|>=?|[-+/=]/,\r\n        alias: 'operator'\r\n      }\r\n    }\r\n    Prism.languages.kum = Prism.languages.kumir\r\n  })(Prism)\r\n}\r\n"]},"metadata":{},"sourceType":"script"}