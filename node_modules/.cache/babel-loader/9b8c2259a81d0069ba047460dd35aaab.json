{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nfunction mergeKeys(currNodeKeys, currKeyIndex, nextNodeKeys, nextKeyIndex) {\n  var allKeys = [];\n\n  for (var i = 0; i < nextNodeKeys.length; i++) {\n    allKeys[i] = nextNodeKeys[i];\n  }\n\n  for (var _i = 0; _i < currNodeKeys.length; _i++) {\n    if (nextKeyIndex[currNodeKeys[_i]] === undefined) {\n      allKeys.push(currNodeKeys[_i]);\n    }\n  }\n\n  return allKeys.sort(function (a, b) {\n    var nextOrderA = nextKeyIndex[a];\n    var nextOrderB = nextKeyIndex[b];\n    var currOrderA = currKeyIndex[a];\n    var currOrderB = currKeyIndex[b];\n\n    if (nextOrderA != null && nextOrderB != null) {\n      return nextKeyIndex[a] - nextKeyIndex[b];\n    } else if (currOrderA != null && currOrderB != null) {\n      return currKeyIndex[a] - currKeyIndex[b];\n    } else if (nextOrderA != null) {\n      for (var _i2 = 0; _i2 < nextNodeKeys.length; _i2++) {\n        var pivot = nextNodeKeys[_i2];\n\n        if (!currKeyIndex[pivot]) {\n          continue;\n        }\n\n        if (nextOrderA < nextKeyIndex[pivot] && currOrderB > currKeyIndex[pivot]) {\n          return -1;\n        } else if (nextOrderA > nextKeyIndex[pivot] && currOrderB < currKeyIndex[pivot]) {\n          return 1;\n        }\n      }\n\n      return 1;\n    }\n\n    for (var _i3 = 0; _i3 < nextNodeKeys.length; _i3++) {\n      var _pivot = nextNodeKeys[_i3];\n\n      if (!currKeyIndex[_pivot]) {\n        continue;\n      }\n\n      if (nextOrderB < nextKeyIndex[_pivot] && currOrderA > currKeyIndex[_pivot]) {\n        return 1;\n      } else if (nextOrderB > nextKeyIndex[_pivot] && currOrderA < currKeyIndex[_pivot]) {\n        return -1;\n      }\n    }\n\n    return -1;\n  });\n}\n\nvar _default = mergeKeys;\nexports[\"default\"] = _default;","map":{"version":3,"sources":["D:/Rnd/sleepyowl/node_modules/react-move/core/mergeKeys.js"],"names":["Object","defineProperty","exports","value","mergeKeys","currNodeKeys","currKeyIndex","nextNodeKeys","nextKeyIndex","allKeys","i","length","_i","undefined","push","sort","a","b","nextOrderA","nextOrderB","currOrderA","currOrderB","_i2","pivot","_i3","_pivot","_default"],"mappings":"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","sourcesContent":["\"use strict\";\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports[\"default\"] = void 0;\r\n\r\nfunction mergeKeys(currNodeKeys, currKeyIndex, nextNodeKeys, nextKeyIndex) {\r\n  var allKeys = [];\r\n\r\n  for (var i = 0; i < nextNodeKeys.length; i++) {\r\n    allKeys[i] = nextNodeKeys[i];\r\n  }\r\n\r\n  for (var _i = 0; _i < currNodeKeys.length; _i++) {\r\n    if (nextKeyIndex[currNodeKeys[_i]] === undefined) {\r\n      allKeys.push(currNodeKeys[_i]);\r\n    }\r\n  }\r\n\r\n  return allKeys.sort(function (a, b) {\r\n    var nextOrderA = nextKeyIndex[a];\r\n    var nextOrderB = nextKeyIndex[b];\r\n    var currOrderA = currKeyIndex[a];\r\n    var currOrderB = currKeyIndex[b];\r\n\r\n    if (nextOrderA != null && nextOrderB != null) {\r\n      return nextKeyIndex[a] - nextKeyIndex[b];\r\n    } else if (currOrderA != null && currOrderB != null) {\r\n      return currKeyIndex[a] - currKeyIndex[b];\r\n    } else if (nextOrderA != null) {\r\n      for (var _i2 = 0; _i2 < nextNodeKeys.length; _i2++) {\r\n        var pivot = nextNodeKeys[_i2];\r\n\r\n        if (!currKeyIndex[pivot]) {\r\n          continue;\r\n        }\r\n\r\n        if (nextOrderA < nextKeyIndex[pivot] && currOrderB > currKeyIndex[pivot]) {\r\n          return -1;\r\n        } else if (nextOrderA > nextKeyIndex[pivot] && currOrderB < currKeyIndex[pivot]) {\r\n          return 1;\r\n        }\r\n      }\r\n\r\n      return 1;\r\n    }\r\n\r\n    for (var _i3 = 0; _i3 < nextNodeKeys.length; _i3++) {\r\n      var _pivot = nextNodeKeys[_i3];\r\n\r\n      if (!currKeyIndex[_pivot]) {\r\n        continue;\r\n      }\r\n\r\n      if (nextOrderB < nextKeyIndex[_pivot] && currOrderA > currKeyIndex[_pivot]) {\r\n        return 1;\r\n      } else if (nextOrderB > nextKeyIndex[_pivot] && currOrderA < currKeyIndex[_pivot]) {\r\n        return -1;\r\n      }\r\n    }\r\n\r\n    return -1;\r\n  });\r\n}\r\n\r\nvar _default = mergeKeys;\r\nexports[\"default\"] = _default;"]},"metadata":{},"sourceType":"script"}